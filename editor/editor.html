<script type="text/javascript">

/////////////////////////////////////////////////////
////////// KNOWN ISSUES SO FAR ///////////////////
//  - Using the UP/DOWN arrow keys to move the cursor 'thru' lines with varying lengths does not behave as a user would expect
//  - HTML-like text does not render correctly: it changes how the line is rendered
// 
//  - NOT YET IMPLEMENTED:
//	--> CTL-END, CTL-HOME, PAGEUP, PAGEDWN
//	--> Handling selection of text (with mouse OR keyboard)
//	--> Auto-scrolling to follow cursor
//
//////////////////////////////////////////////////

////////////////////////////////////////////////////
/////////// RESOLVED ISSUES SO FAR /////////////////
//  ISSUE : When typing, it is not currently possible to have two consecutive spaces, for some odd reason...
//  		---- RELATED :  When placing the cursor on an existing space, typing another space makes the cursor disappear and does not add more spaces
//  SOLUTION : In the HTML "wrapper" of the document being edited, a CSS style of 'white-space:pre' needs to be applied.
//
//  ISSUE : Placing the cursor at the last position of the line makes the cursor disappear (although it still works)
//  SOLUTION <<OUTDATED>>: Added a line in the 'renderCursor' function, which adds a temporary space to the line so that the cursor can be rendered. 
//  SOLUTION 2 : added BUGFIX_SPACE function to textDocument object, and made cursorColumn-related code compatible to this change
//
//  ISSUE : Pressing "ENTER" breaks the app.
//  SOLUTION : Correctly implemented ENTER-key functionality in the typeSpecial function.  Required an update to the textDocument object, outlined above
//
//  ISSUE :  Typing a single quote starts a "quick find" in firefox.  Have not yet prevented this from occurring.
//  ISSUE :  Tab key is not captured correctly (moves to next tab space in overall document rather than types 4 spaces)
//  ISSUE :  The content window scrolls at a different rate than the cursor, so often the cursor disappears from the screen in a long document
//  SOLUTION : Adjusted the <body> tag in editableContent.html to read <body onkeypress="return false;"> in order to prevent the event from bubbling past the doc
//			Miraculously, it doesn't break text insertion!  Lucky break!
//
///////////////////////////////////////////////////

///////////////////////////////////////////////////
////////////// IT'S ALL IN THE DETAILS /////////////
//  TODO:  Keep track of "tab stops" in the document so that a tab only inserts enough spaces to go to the next multiple of 4 characters across
//
///////////////////////////////////////////////////

/**********************************************/
/************ CUSTOM DATA TYPES ****************/

// Data structure to hold unformatted document
function textDocument() 
{
	//////////////////////////////////////////////////
	////////////// MEMBER VARIABLES ////////////////
	
	// Sub-data structure for each lineId,lineText pair
	this.line = function( paramLineId, paramLineText )
	{
		this.id = paramLineId;
		this.text = paramLineText;
	}
	this.document = new Array();		// This is to be an array of lines
	this.uniqueNameCounter = 0;		// This variable is used to provide unique id's to each line
	
	//////////////////////////////////////////////////
	////////////// MEMBER FUNCTIONS ///////////////
	
	// This function adds a line to the end of the document
	this.appendLine = function( paramText ) {
		this.insertLine( this.getDocumentLength(), paramText );
	}
	//  Clears the contents of the document
	this.blankDocument = function() {
		this.document = new Array();
	}
	// Returns the length of the document in number of lines
	this.getDocumentLength = function() {
		return this.document.length;
	}
	// Returns the length of the specified line
	this.getLineLength = function( paramLineNum ) {
		if ( paramLineNum < this.getDocumentLength() ) return this.getLineText( paramLineNum ).length;
		else return false;
	}
	// Returns the id of the specified line
	this.getLineId = function( paramLineNum ) {
		if ( paramLineNum < this.document.length && paramLineNum != -1 ) return this.document[paramLineNum].id;
		else return false;
	}
	// Returns the text of the specified line
	this.getLineText = function( paramLineNum ) {
		if ( paramLineNum < this.getDocumentLength() && this.document[paramLineNum] != undefined ) {
			return this.document[paramLineNum].text;
		}
		else return false;
	}
	// Insert a line with the given text into the document at the specified line number
	this.insertLine = function( paramLineNum, paramText ) {
		paramText = this.replaceTab( paramText );
		paramText = this.BUGFIX_SPACE( paramText );
		
		if ( paramLineNum <= this.getDocumentLength() && paramLineNum >= 0 ) {
			this.document.splice( paramLineNum, 0, new this.line( "line"+this.uniqueNameCounter, paramText ) );
			this.uniqueNameCounter++;
		} else return false;
	}
	// Remove a line, specified by line number
	this.removeLine = function( paramLineNum ) {
		if ( paramLineNum <= this.getDocumentLength() && paramLineNum >= 0 ) this.document.splice( paramLineNum, 1 );
		else return false;
	}
	// Replace tabs with 4 spaces
	this.replaceTab = function( paramText ) {
		return paramText.replace(/\t/g,"    ");
	}
	/* NOTE: setLineId is deliberately omitted.  Id's shall be handled internally by the document structure during line creation only */
	// Set the text of a specified line to equal paramText
	this.setLineText = function( paramLineNum, paramText ) {
		paramText = this.BUGFIX_SPACE( paramText );
		if ( paramLineNum < this.getDocumentLength() ) {
			this.document[paramLineNum].text = paramText;
		}
		else return false;
	}
	// BUGFIX FUNCTION.  Returns paramText, after ensuring the last char is a space character
	this.BUGFIX_SPACE = function( paramText ) {
		// FIX RENDERING ISSUE FOR HTML: If last character of a line is not a space character, then append one.
		// This fixes 2 things: 1.) allows the cursor to be at the 'true' end of the line
		//                      2.) fixes bug where blank lines are not rendered
		if ( paramText.charAt(paramText.length-1) != ' ' ) paramText = paramText + ' ';
		return paramText;
	}	
}


/**********************************************/
/********** DECLARE GLOBAL VARIABLES **********/

// Browser(HTML) document related globals
var myIFrame;
var mainDoc;

// Browser specific
var isFF;
var isIE;
var isChrome;
var isSafari;

// CSS related constants
var FONT_WIDTH = 8;
var FONT_HEIGHT = 17;
var PADDING_TOP = 8;
var PADDING_LEFT = 8;

// Text document container
var XPODoc = new textDocument();

// Mouse and cursor related globals
var mouseX;
var mouseY;
var cursorLine;
var cursorColumn;
var selectionAnchorLine;
var selectionAnchorColumn;

// Text-editing related global flags (to be treated as BOOLEAN variables)
var isSelection;
var isInsertMode;
var isShiftDown;
var isCtlDown;
var isAltDown;

// Global constants
// Special keys
var BACKSPACEKEY = 8;
var TABKEY = 9;
var ENTERKEY = 13;
var CAPSLOCKKEY = 20;
var DELETEKEY = 46;
var SPACEKEY = 32;
var PAGEUPKEY = 33;
var PAGEDOWNKEY = 34;
var ENDKEY = 35;
var HOMEKEY = 36;
var LEFTARROWKEY = 37;
var UPARROWKEY = 38;
var RIGHTARROWKEY = 39;
var DOWNARROWKEY = 40;
var INSERTKEY = 45;
var SHIFTKEY = 16;

// Input modes
var INSERT = 0;
var OVERWRITE = 1;

// Other GUI related handles
var cursor_line_box;
var cursor_column_box;
var mouse_x_box;
var mouse_y_box;

var readOnly;

function getDoc(){
	if(isIE == true){
		return myIFrame.document;
	}
	else{
		return myIFrame.contentWindow.document;
	}
}

/**********************************************/
/**** MOUSE AND CURSOR ACCESSOR FUNCTIONS *****/

// These functions are self-explanatory
function captureMousePos(e) {
	if(isIE == true){
		//this is cory's attempt... its not perfect, but it shows how you can do it
		e = myIFrame.window.event;
		mouseX = e.clientX + getDoc().body.scrollLeft - 3;
        mouseY = e.clientY + getDoc().body.scrollTop - 3;
	}
	else{
		mouseX = e.pageX;
		mouseY = e.pageY;
	}
}
function getMouseCoords() {
	return [mouseX, mouseY];
}
function getMouseX() {
	return mouseX;
}
function getMouseY() {
	return mouseY;
}

// This function calculates the position of the cursor 
// based on the given parameters representing mouseX,Y
function deriveCursor(paramMouseX, paramMouseY) {

	// Calculate line and column number based on mouse position
	var currow = Math.floor((mouseY - PADDING_TOP)/FONT_HEIGHT);
	var curcol = Math.floor((mouseX - PADDING_LEFT)/FONT_WIDTH);
	// Perform sanity check on calculated values:
	// If the calculated line is below the last line, then set cursor at last character in document
	if (currow > XPODoc.getDocumentLength()-1) {
		currow = XPODoc.getDocumentLength()-1;
		curcol = XPODoc.getLineLength( XPODoc.getDocumentLength()-1 );
	}
	// If the calculated cursor is beyond the first or last character in a line, 
	// then set the cursor to the first or last character, respectively
	else {		
		if ( curcol < 0 ) curcol = 0;
		if ( curcol >= XPODoc.getLineLength(currow) ) curcol = XPODoc.getLineLength(currow)-1;
	}
	// Store the calculated values
	cursorLine = currow;
	cursorColumn = curcol;
}
// These functions are self-explanatory again
function getCursor() {
	return [cursorLine,cursorColumn];
}
function getCursorLine() {
	return cursorLine;
}
function getCursorColumn() {
	return cursorColumn;
}
function getScrollOffsetX() {
	if(isIE == true){
		return getDoc().body.scrollLeft;
	}
	else{
		return myIFrame.contentWindow.pageXOffset;
	}
}
function getScrollOffsetY() {
	if(isIE == true){
		return getDoc().body.scrollTop;
	}
	else{
		return myIFrame.contentWindow.pageYOffset;
	}
}



/**********************************************/
/******** SELECTION RELATED FUNCTIONS *********/

// These functions returns the position of the selection anchor
function getSelectionAnchor() {
	return [selectionAnchorLine, selectionAnchorColumn];
}
function getSelectionAnchorLine() {
	return selectionAnchorLine;
}
function getSelectionAnchorColumn() {
	return selectionAnchorColumn;
}
// This function sets selection mode 'on', and furthermore sets the 
// selectionAnchor position to the current cursor position
function setSelection() {
	selectionAnchorLine = cursorLine;
	selectionAnchorColumn = cursorColumn;
	isSelection = true;
}
// This function sets selection mode 'off'.
function resetSelection() {
	isSelection = false;
}



/**********************************************/
/******** USER INPUT RELATED FUNCTIONS ********/

// This function is responsible for recalculating the cursor position
// after a command to move the cursor has been issued. It takes as a 
// parameter a DIRECTION, of which valid values are defined above in
// the global variable declarations
function typeSpecial(paramKEYCODE) {

	switch ( paramKEYCODE ) {
	
		case LEFTARROWKEY: 
			// If we are at the first char of the first line do nothing
			// If we are at the first char of any other line, wrap to the last char of the previous line
			// Otherwise, simply move left
			if ( cursorColumn == 0 && cursorLine == 0 ) break;
			if ( cursorColumn == 0 ) {
				cursorLine--;
				cursorColumn = XPODoc.getLineLength(cursorLine)-1;
			}
			else cursorColumn--;			
			break;
			
		case RIGHTARROWKEY:
			// If we are at the last char of the last line, do nothing
			// If we are at the last char of any other line, wrap to the first char of the next line
			// Otherwise, simply move right
			if ( cursorColumn == XPODoc.getLineLength(cursorLine)-1 && cursorLine == XPODoc.getDocumentLength()-1 ) break;
			if ( cursorColumn == XPODoc.getLineLength(cursorLine)-1 ) {
				cursorLine++;
				cursorColumn = 0;
			}
			else cursorColumn++;
			break;
			
		case UPARROWKEY:
			// If we are on the first line, move to first char of line.
			// Otherwise, move up. If we end up out of range of the line, move to the last char of the line
			if ( cursorLine == 0 ) cursorColumn = 0;
			else if ( cursorColumn > XPODoc.getLineLength(--cursorLine) ) cursorColumn = XPODoc.getLineLength(cursorLine)-1;
			break;
			
		case DOWNARROWKEY:
			// If we are on the last line, move to last char of line.
			// Otherwise, move down. If we end up out of range of the line, move to the last char of the line
			if ( cursorLine == XPODoc.getDocumentLength()-1 ) cursorColumn = XPODoc.getLineLength(cursorLine)-1;
			else if ( cursorColumn > XPODoc.getLineLength(++cursorLine) ) cursorColumn = XPODoc.getLineLength(cursorLine)-1;
			break;
			
		case ENDKEY:
			// Move to the last char of the current line
			cursorColumn = XPODoc.getLineLength(cursorLine)-1;
			break;
			
		case HOMEKEY:
			// Move to the first char of the current line
			cursorColumn = 0;
			
		case PAGEUPKEY:
			// Move the cursor up a number of time relative to the current editing window's height			
			if(isIE == true){
				cursorLine -= Math.floor(getDoc().body.clientHeight / FONT_HEIGHT);
			}
			else{
				cursorLine -= Math.floor(myIFrame.contentWindow.innerHeight / FONT_HEIGHT);
			}
			// Do out-of-bounds checks
			if ( cursorLine < 0 ) {
				cursorLine = 0;
				cursorColumn = 0;
			} else if ( cursorColumn >= XPODoc.getLineLength( cursorLine ) ) cursorColumn = XPODoc.getLineLength(cursorLine)-1;
			if(isIE == true){
				myIFrame.scrollBy(0,-getDoc().body.clientHeight+PADDING_TOP);
			}
			else{
				myIFrame.contentWindow.scrollBy(0,-myIFrame.contentWindow.innerHeight+PADDING_TOP);
			}
			break;
					
		case PAGEDOWNKEY:
			// Move the cursor down a number of times relative to the current editing window's height
			if(isIE == true){
				cursorLine += Math.floor(getDoc().body.clientHeight / FONT_HEIGHT);
			}
			else{
				cursorLine += Math.floor(myIFrame.contentWindow.innerHeight / FONT_HEIGHT);
			}
			// Do out-of-bounds checks
			if ( cursorLine > XPODoc.getDocumentLength()-1 ) {
				cursorLine = XPODoc.getDocumentLength()-1;
				cursorColumn = XPODoc.getLineLength( cursorLine )-1;
			} else if ( cursorColumn >= XPODoc.getLineLength( cursorLine ) ) cursorColumn = XPODoc.getLineLength(cursorLine)-1;
			if(isIE == true){
				myIFrame.scrollBy(0,getDoc().body.clientHeight-PADDING_TOP);
			}
			else{
				myIFrame.contentWindow.scrollBy(0,myIFrame.contentWindow.innerHeight-PADDING_TOP);
			}
			break;
			
		case BACKSPACEKEY:
			// If we are on the first char of the first line, do nothing.
			// If we are on the first char of any other line, backspace removes the "newline character"
			// -- which doesn't exist in our implementation.  We simulate this removal by merging lines.
			// Otherwise, we simply remove the previous char in the current line
			if ( cursorLine == 0 && cursorColumn == 0 ) break;
			if ( cursorColumn == 0 ) {
				// Merge the two lines, and remove the original line
				cursorColumn = XPODoc.getLineLength( cursorLine-1 );	// Place cursor at end of prior line
				// Perform text merge into prior line
				XPODoc.setLineText( cursorLine-1, XPODoc.getLineText( cursorLine-1 ) + XPODoc.getLineText( cursorLine ) );
				
				// FIXME: HACK:  BAD FORM!  The following lines promote tight coupling between GUI and backend!  ARRRGGGGHHHHH! 
				var removeMe = getDoc().getElementById(XPODoc.getLineId( cursorLine ));
				removeMe.parentNode.removeChild(removeMe);
				
				// Remove the line from our data structure
				XPODoc.removeLine( cursorLine );
				// Decrement cursorLine
				cursorLine--;
			} else {
				// "Remove" the character prior to cursorColumn, and decrement cursorColumn
				var tempText = XPODoc.getLineText( cursorLine );
				XPODoc.setLineText( cursorLine, tempText.substring(0,cursorColumn-1) + tempText.substring(cursorColumn--) );
			}
			break;
			
		case DELETEKEY:
			// If we are at the last char of the last line, do nothing
			// If we are at the last char of any other line, we remove the 'newline character', thus merging the current line with the next line
			// Otherwise, we simply remove the char at the cursor position
			if ( cursorColumn == XPODoc.getLineLength( XPODoc.getDocumentLength()-1 )-1 && cursorLine == XPODoc.getDocumentLength()-1 ) break;
			if ( cursorColumn == XPODoc.getLineLength( cursorLine )-1 ) {
				// Merge the next line into the current line
				XPODoc.setLineText( cursorLine, XPODoc.getLineText(cursorLine) + XPODoc.getLineText(cursorLine+1) );
				
				// FIXME: HACK:  BAD FORM!  The following lines promote tight coupling between GUI and backend!  ARRRGGGGHHHHH! 
				var removeMe = getDoc().getElementById(XPODoc.getLineId( cursorLine+1 ));
				removeMe.parentNode.removeChild(removeMe);
				
				// Remove the line in question from our data structure
				XPODoc.removeLine( cursorLine+1 );
			} else {
				// "Remove" the character at the cursorColumn position
				var tempText = XPODoc.getLineText( cursorLine );
				XPODoc.setLineText( cursorLine, tempText.substring(0,cursorColumn) + tempText.substring(cursorColumn+1) );
			}
			break;
			
		case ENTERKEY:
			// When we press the enter key, we need to insert a new line into the document
			// We need to insert a new line following the current line, which contains the current line's text starting from the cursor
			XPODoc.insertLine( cursorLine+1, XPODoc.getLineText( cursorLine ).substring( cursorColumn ) );
			XPODoc.setLineText( cursorLine, XPODoc.getLineText( cursorLine ).substring( 0, cursorColumn ) );

			// TODO: FIXME: HACK:  Need to make the above change visible in the GUI
			clearFormatting( cursorLine );
			var myDoc = getDoc();
			var addMe = myDoc.createElement('div');
			addMe.setAttribute('id', XPODoc.getLineId( cursorLine+1 ) );
			addMe.setAttribute('class', "line");
			myDoc.getElementById("entireDocument").insertBefore( addMe, myDoc.getElementById( XPODoc.getLineId( cursorLine+2 ) ) );
				
			cursorLine++;
			cursorColumn = 0;
			break;
			
		case TABKEY:
			// Insert 4 spaces at current cursor position
			//  SUPER HACK:  Need to redesign functions a bit to eliminate redundancy and make it cleaner and more readable.  
			// We eventually want this to call an "insertText()" function, but for now....
			typeCharacter(" ".charCodeAt(0) );
			typeCharacter(" ".charCodeAt(0) );
			typeCharacter(" ".charCodeAt(0) );
			typeCharacter(" ".charCodeAt(0) );
			break;
		case SHIFTKEY:
		
			break;
		case CAPSLOCKKEY:
			
			break;
		case SPACEKEY:
			typeCharacter(" ".charCodeAt(0) );
			break;
		default:
			return false;
	}
	return true;
} // END typeSpecial(paramKEY)

// This function toggles the InsertMode flag (representing Insert or Overwrite)
function toggleInputMode() {
	if ( isInsertMode ) isInsertMode = false;
	else isInsertMode = true;
}
// This explicitly sets whether Insert Mode or Overwrite Mode is active
function setInputMode( paramMODE ) {
	isInsertMode = paramMODE;
}
// This function is responsible for analyzing a keyPressEvent and subsequently
// executing the appropriate function, based on the charCode
function type( paramEvent ) {
	// If we can't find the current line, just bail out
	if( XPODoc.getLineText(cursorLine) == false ) return;
	
	// This needs a lot of cleanup...
	var evt;
	if(isFF == true){
		if ( paramEvent.charCode != 0 ) typeCharacter( paramEvent.charCode );
		else typeSpecial( paramEvent.keyCode );
		return;
	}
	else if(isIE == true){
		evt = myIFrame.window.event;
	}
	else if(isChrome == true || isSafari == true){
		evt = paramEvent;
	}
	else{
		alert('an unknown browser... editing may not work.');
	}
	
	// No browses besides FF are kind enough to have a charCode property...  We have to find out ourselves which character to display
	var key = evt.keyCode;
	if((key >= 48 && key <= 126) || (key >= 186 && key <= 192) || (key >= 219 && key <= 222)){
		var charCode = getCharCode(key, evt.shiftKey);		
		if(charCode != null) typeCharacter(charCode);
	}
	else{
		typeSpecial( key );
	}

	//if ( key != 0 ) typeCharacter( key );
	//else typeSpecial( key );	
}

function getCharCode( paramKey, paramShiftPressed ){

	if(paramShiftPressed){
		if(paramKey >= 65 && paramKey <= 90) //A-Z a-z
			return paramKey;
		else if(paramKey == 49) // 1 !
			return 33;
		else if(paramKey == 50) // 2 @
			return 64;
		else if(paramKey == 51) // 3#
			return 35;
		else if(paramKey == 52) // 4$
			return 36;
		else if(paramKey == 53) // 5%
			return 37;
		else if(paramKey == 54) // 6^
			return 94;
		else if(paramKey == 55) // 7&
			return 38;
		else if(paramKey == 56) // 8*
			return 42;
		else if(paramKey == 57) // 9(
			return 40;
		else if(paramKey == 48) // 0)
			return 41;
		else if(paramKey == 186) // :
			return 58;
		else if(paramKey == 187) // +
			return 43;
		else if(paramKey == 188) // <
			return 60;
		else if(paramKey == 189) // _
			return 95;
		else if(paramKey == 190) // >
			return 62;
		else if(paramKey == 191) // ?
			return 63;
		else if(paramKey == 192) // ~
			return 126;
		else if(paramKey == 219) // {
			return 123;
		else if(paramKey == 220) // |
			return 124;
		else if(paramKey == 221) // }
			return 125;
		else if(paramKey == 222) // "
			return 34;
	}
	else{
		if(paramKey >= 65 && paramKey <= 90) //a-z
			return paramKey + 32;
		else if(paramKey >= 48 && paramKey <= 57) //0-9
			return paramKey;
		else if(paramKey == 186) // ;
			return 59;
		else if(paramKey == 187) // =
			return 61;
		else if(paramKey == 188) // ,
			return 44;
		else if(paramKey == 189) // -
			return 45;
		else if(paramKey == 190) // .
			return 46;
		else if(paramKey == 191) // /
			return 47;
		else if(paramKey == 192) // `
			return 96;
		else if(paramKey == 219) // [
			return 91;
		else if(paramKey == 220) // \
			return 92;
		else if(paramKey == 221) // ]
			return 93;
		else if(paramKey == 222) // '
			return 39;		
	}
	return null;
}

// This function is responsible for text input
function typeCharacter( paramCharCode ) {	
	var tempCurrentLine = new Array();
	tempCurrentLine.push(XPODoc.getLineText(cursorLine).substring(0,cursorColumn));
	tempCurrentLine.push(XPODoc.getLineText(cursorLine).substr(cursorColumn, 1));
	tempCurrentLine.push(XPODoc.getLineText(cursorLine).substring(cursorColumn+1));

	// Insert character
	tempCurrentLine[1]=String.fromCharCode(paramCharCode) + tempCurrentLine[1];
	
	// Update cursor
	cursorColumn++;
	
	// Commit changes
	XPODoc.setLineText( cursorLine, tempCurrentLine.join("") );
}



/*************************************************/
/**** LINE MANAGEMENT / DOCUMENT ORGANIZATION ****/



/**********************************************/
/**** GUI RELATED / GUI SPECIFIC FUNCTIONS ****/

// This function diplays the mouse position in the GUI
function displayMousePos() {
	mouse_x_box.value = mouseX;
	mouse_y_box.value = mouseY;
}
// This function displays the cursor position in the GUI
function displayCursorPos() {
	updateLineCol(cursorLine, cursorColumn);
	//cursor_line_box.value = cursorLine;
	//cursor_column_box.value = cursorColumn;
}
// This function clears the formatting of the line specified by paramLineNumber
function clearFormatting( paramLineNum ) {
	if(getDoc().getElementById( XPODoc.getLineId(paramLineNum) ) != null){
		getDoc().getElementById( XPODoc.getLineId(paramLineNum) ).innerHTML = XPODoc.getLineText(paramLineNum);
	}
}
// This function clears the old cursor and moves to the line specified by paramLineNumber
function gotoLine( paramLineNum ) {
	clearFormatting(cursorLine);
	cursorLine = paramLineNum;
	cursorColumn = 0;
	renderCursor();
	adjustScroll();
}
// This function clears the old cursor and moves to the line specified by paramLineNumber
function gotoPosition( paramLineNum, paramColNum ) {
	clearFormatting(cursorLine);
	cursorLine = paramLineNum;
	cursorColumn = paramColNum;
	renderCursor();
	adjustScroll();
}
// This function renders the cursor in the document. 
function renderCursor() {
	if(XPODoc.getLineText(cursorLine) == false) return;
	// Slice 'n dice the line to isolate the cursor
	var tempCurrentLine = new Array();
	tempCurrentLine.push(XPODoc.getLineText(cursorLine).substring(0,cursorColumn));
	tempCurrentLine.push(XPODoc.getLineText(cursorLine).substr(cursorColumn, 1));
	tempCurrentLine.push(XPODoc.getLineText(cursorLine).substring(cursorColumn+1));
	// Apply formatting
//	if ( tempCurrentLine[1].length == 0 ) tempCurrentLine[1]=" ";  // <--- FIX#2
	tempCurrentLine[1] = "<font style='BACKGROUND-COLOR: red'>" + tempCurrentLine[1] + "</font>";
	// display new formatting
	try {
		getDoc().getElementById( XPODoc.getLineId(cursorLine) ).innerHTML = tempCurrentLine.join("");
	}
	catch (e) { alert("line not found!"); }
	
	// Update the GUI with the correct line and col
	displayCursorPos();
}
// This function re-renders the entire document
function refreshDocument() {
	var myDoc = getDoc().getElementById("entireDocument");
	while ( myDoc.firstChild ) {
		myDoc.removeChild( myDoc.firstChild );
	}
	
	for(var l=0; l < XPODoc.document.length; l++ ){
		var newLine = getDoc().createElement('div');
		newLine.setAttribute('id', XPODoc.getLineId(l) );
		newLine.setAttribute('class', "line");		// RELATED TO FIX OF ISSUE #1
		myDoc.appendChild( newLine );				
		if ( l == cursorLine ) {renderCursor();}
		else clearFormatting( l );
	}
}
// This function will perform auto-scrolling of the IFrame to keep the cursor in view at all times
function adjustScroll() {
	// TODO: COMMENT THIS FUNCTION
	var frameWidth;
	var frameHeight;
	if(isIE == true){
		frameWidth = getDoc().body.clientWidth;
		frameHeight = getDoc().body.clientHeight;
	}
	else{
		frameWidth = myIFrame.contentWindow.innerWidth;
		frameHeight = myIFrame.contentWindow.innerHeight;
	}

	//var frameWidth = myIFrame.contentWindow.innerWidth;
	//var frameHeight = myIFrame.contentWindow.innerHeight;
	var cursorDocOffsetX = (cursorColumn*FONT_WIDTH) + PADDING_LEFT;
	var cursorDocOffsetY = (cursorLine*FONT_HEIGHT) + PADDING_TOP;
	var visibleEdgeX = getScrollOffsetX()+frameWidth-FONT_WIDTH;
	var visibleEdgeY = getScrollOffsetY()+frameHeight-FONT_HEIGHT;
	var scrollAmountX=0;
	var scrollAmountY=0;
	
	if (cursorDocOffsetX>visibleEdgeX) scrollAmountX=cursorDocOffsetX-visibleEdgeX+100;
	else if (cursorDocOffsetX<getScrollOffsetX()) scrollAmountX=cursorDocOffsetX-getScrollOffsetX()-100;
	if (cursorDocOffsetY>visibleEdgeY) scrollAmountY=cursorDocOffsetY-visibleEdgeY+100;
	else if (cursorDocOffsetY<getScrollOffsetY()) scrollAmountY=cursorDocOffsetY-getScrollOffsetY()-100;
	
	if(isIE == true){
		myIFrame.scrollBy(scrollAmountX, scrollAmountY);
	}
	else{
		myIFrame.contentWindow.scrollBy(scrollAmountX, scrollAmountY);
	}
}



/********************************************/
/********** INITIALIZATION FUNCTION *********/
// FIXME:  I SUCK
function init() {
	var ua = navigator.userAgent.toLowerCase();	
	isFF = (ua.indexOf("firefox") != -1);
	isIE = (ua.indexOf("msie") != -1);
	isChrome = (ua.indexOf("chrome") != -1);
	isSafari = (ua.indexOf("safari") != -1) && (ua.indexOf("chrome") == -1);
	
	if(isIE == false){
		myIFrame = document.getElementById("myI");
	}
	else{
		myIFrame = frames["myI"];
	}
	mainDoc = document;

	mouse_x_box = document.getElementById("mX");
	mouse_y_box = document.getElementById("mY");
	cursor_line_box = document.getElementById("cL");
	cursor_column_box = document.getElementById("cC");

	cursorLine = 0;
	cursorColumn = 0;

	//*****Populate our data structure***********
	var curline = "";
	var curlineName = "";
	var nextline = 0;
}
// FIXME:  ^^^ REALLY THIS SUCKS

function loadNewDoc(docText, accessMode) {
	XPODoc.blankDocument();
	var textArr = docText.split(/\r\n|\r|\n/);
	for(var i=0; i < textArr.length; i++ ){
		XPODoc.appendLine( textArr[i] );
	}
	//********** Done populating data structure **********
	
	readOnly = (accessMode == "r");
	
	// Render the entire document's HTML
	refreshDocument();
	
	// Only enable listeners in write mode
	if(readOnly == false){
		if(isIE == true || isChrome == true || isSafari == true){
			getDoc().onclick = function(event){clearFormatting(cursorLine);captureMousePos(event);deriveCursor();renderCursor();};
			getDoc().onkeydown = function(event){clearFormatting(cursorLine);type(event);renderCursor();adjustScroll();return false;};
		}
		else{
			getDoc().addEventListener("click",function(e){clearFormatting(cursorLine);captureMousePos(e);deriveCursor();renderCursor();}, true);
			getDoc().addEventListener("keypress",function(e){clearFormatting(cursorLine);type(e);renderCursor();adjustScroll();}, true);
		}
		
		// Enable immediate editing
		if(isIE == true) myIFrame.focus();
		else myIFrame.contentWindow.focus();
	}
	else{
		if(isIE == true || isChrome == true || isSafari == true){
			getDoc().onclick = null;
			getDoc().onkeydown = null;
		}
		else{
			// Remove event listener for FF here...
		}
	}
}

</script>
<iframe id="myI" name="myI" src="./editor/editableContent.html" style="width:100%;height:100%;"></iframe><br />