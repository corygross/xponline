<script type="text/javascript" charset="utf-8" src="tokensearch.js"></script>
<script type="text/javascript" charset="utf-8" src="writeSpans.js"></script>
<script type="text/javascript" charset="utf-8" src="editor/RendererClass.js"></script>
<script type="text/javascript" charset="utf-8" src="editor/TextDocumentClass.js"></script>
<script type="text/javascript" charset="utf-8" src="editor/userInputLogic.js"></script>
<script type="text/javascript" src="jWords.js"></script>
<script type="text/javascript" charset="utf-8" src = "editor/toggleSH.js"></script>
<script type="text/javascript">

/**********************************************/
/********** DECLARE GLOBAL VARIABLES **********/

// Browser(HTML) document related globals
var myIFrame;
var mainDoc;

// Browser specific
var isFF;
var isIE;
var isChrome;
var isSafari;

// CSS related constants
var FONT_WIDTH = 8;
var FONT_HEIGHT = 17;
var PADDING_TOP = 8;
var PADDING_LEFT = 8;

// Text document container
var XPODoc;

// Text-editing related global flags (to be treated as BOOLEAN variables)
var isShiftDown;
var isCtlDown;
var isAltDown;

// Other stuff
var readOnly = true;
var syntaxHighlightOn = true;
var lockedLines = new Array();

// HTML-DOM handle for document pane
var guiDoc;

/*********** END OF GLOBAL VARIABLES ********/
/**********************************************/

function getDoc(){
	return guiDoc;
}


// This function does a raw capture of mouse position, given an event
function captureMousePos(e) {
	if(isIE == true){
		//this is cory's attempt... its not perfect, but it shows how you can do it
		e = myIFrame.window.event;
		mouseX = e.clientX + guiDoc.body.scrollLeft - 3;
        mouseY = e.clientY + guiDoc.body.scrollTop - 3;
	}
	else{
		mouseX = e.pageX;
		mouseY = e.pageY;
	}
}

/* These two functions return the numeric value for the scroll offset of the iFrame */
function getScrollOffsetX() {
	if(isIE == true) return guiDoc.body.scrollLeft;
	else return myIFrame.contentWindow.pageXOffset;
}
function getScrollOffsetY() {
	if(isIE == true) return guiDoc.body.scrollTop;
	else return myIFrame.contentWindow.pageYOffset;
}



/**************************************************/
/******** USER INPUT RELATED FUNCTIONS ********/

// This function inserts a bookmark into the document and displays it
function insertBookmark( paramBMtext ) {
	if( XPODoc.getLineText( cursorLine ).trim() == "" ){
		XPODoc.setLineText( cursorLine, paramBMtext );
	}
	else{
		XPODoc.insertLine( cursorLine+1, XPODoc.getLineText( cursorLine ) );
		XPODoc.setLineText( cursorLine, paramBMtext );		
	}
	cursorColumn = paramBMtext.length;
	XPODoc.renderUpdates( cursorLine, cursorColumn );
}



/*************************************************/
/**** GUI RELATED / GUI SPECIFIC FUNCTIONS ****/

// This function displays the cursor position in the GUI
function displayCursorPos() {
	updateLineCol(cursorLine, cursorColumn);
}

// This function clears the formatting of the line specified by paramLineNumber
//function clearFormatting( paramLineNum ) {
//	if(guiDoc.getElementById( XPODoc.getLineId(paramLineNum) ) != null){
//		//guiDoc.getElementById( XPODoc.getLineId(paramLineNum) ).innerHTML = XPODoc.getLineText(paramLineNum)
//
//		//RT - NOT SURE WHAT THIS DOES....
//		//Parses the contents of each line for syntax hightlighting.
//		guiDoc.getElementById( XPODoc.getLineId(paramLineNum) ).innerHTML = indexLineText(replaceHTMLEntities(XPODoc.getLineText(paramLineNum)));
//		guiDoc.getElementById( XPODoc.getLineId(paramLineNum) ).innerHTML = indexLineText(XPODoc.getLineText(paramLineNum));
//	}
//}

// This function gives the document focus.  This is called when the document is loaded and when popup windows are closed
function giveDocumentFocus(){
	if(isIE == true) myIFrame.focus();
	else myIFrame.contentWindow.focus();
}

// This function clears the old cursor and moves to the line specified by paramLineNumber
function gotoLine( paramLineNum ) {
	gotoPosition( paramLineNum, 0 );
}

// This function clears the old cursor and moves to the line specified by paramLineNumber
function gotoPosition( paramLineNum, paramColNum ) {
	XPODoc.setLineUpdated( cursorLine );
	XPODoc.setLineUpdated( paramLineNum );
	setCursor( paramLineNum, paramColNum );
	XPODoc.renderUpdates( cursorLine, cursorColumn );
	displayCursorPos();
	adjustScroll();
}

// This function takes each line of input and applies formatting based on keywords
function indexLineText(inputText)
{
// This function or a subsequent one is slow as hell.  bypass that for now by just returning the inputtext
return inputText;
	var newLine = "";
//	var testArr = new Array("public", "static", "void");
	var words = inputText.split(" ");
	

		for(var counter = 0; counter < words.size(); counter++)
		{	
			var curWord = words[counter];
	
			if(tokenSearch(curWord))
			{
				var markedWord = writeSpans(curWord, "");
				newLine += markedWord;
				newLine += writeSpans("", "space");
			}
			else
			{
				var unmarkedWord = writeSpans(curWord, "none");
				newLine += unmarkedWord;
				newLine += writeSpans("", "space");
			}
	//	}
	}
	return newLine;
}

// This function highlights and locks lines given by the 'newLineLocks' array it receives
function lockLines( newLineLocks ) {
	// Clear the old line locks
	for( var i=0; i < lockedLines.length; i++ )
	{
		XPODoc.setLineUpdated( lockedLines[i].lineID );
		//clearFormatting( lockedLines[i].lineID );
	}
	// Add the new line locks
	for( var j=0; j < newLineLocks.length; j++ )
	{		
		// Below is the old way to render locks
		//guiDoc.getElementById( XPODoc.getLineId(newLineLocks[j].lineID) ).innerHTML = "<span class='lock' onMouseOver=\"makeNewLockPopup(event,'lock"+j+"','"+newLineLocks[j].userName+"')\" onMouseOut=\"closeLockPopup('lock"+j+"')\">" + XPODoc.getLineText(newLineLocks[j].lineID) + "</span>";		
	}
	lockedLines = newLineLocks;
}

// This function renders the cursor in the document. 
function renderCursor() 
{
	             // Slice 'n dice the line to isolate the cursor
	                var tempCurrentLine = new Array();

	                tempCurrentLine.push(XPODoc.getLineText(cursorLine).substring(0,cursorColumn));
	                tempCurrentLine.push(XPODoc.getLineText(cursorLine).substr(cursorColumn, 1));
	                tempCurrentLine.push(XPODoc.getLineText(cursorLine).substring(cursorColumn+1));

					//If syntax highlighting is enabled
					if(checkSyntaxHighlighting())
					{
						//Parse the line text for any tokens and return the parsed html
		                var formatted = indexLineText(tempCurrentLine[0] + tempCurrentLine[1] + tempCurrentLine[2]);
										
						//An attempt to get all of the span tags in the current line
						var allSpans = new RegExp("<span\\b[^>]*>(.*?)</span> ?", "g");							
						
						var spansArray = formatted.match(allSpans, "gi");
							
							//If the line is empty, then just render the cursor where it is
							if(spansArray == null)
							{
								tempCurrentLine[1] = "<span id='cursor'>" + tempCurrentLine[1] + "</span>";  
								guiDoc.getElementById( XPODoc.getLineId(cursorLine) ).innerHTML = tempCurrentLine.join("")
								return;
							}
							else
							{
								//Grab the cursorColumn-th span in the array, which is where the 
								//cursor should be
								var cursorOn = "";
								cursorOn = spansArray[cursorColumn];
				
								var cursorRegExp = new RegExp("<span\\b[^>]*>");
								var temp = cursorOn.replace(cursorRegExp, "<span id='cursor'>");

								spansArray[cursorColumn] = temp;
								
								delete cursorOn;
								delete cursorRegExp;
								delete temp;
								
								var newString = "";
								for(var counter = 0; counter < spansArray.size(); counter++)
								{
									newString +=spansArray[counter];
								}
							}
						  	// display new formatting
		                	try 
							{
		                        guiDoc.getElementById( XPODoc.getLineId(cursorLine) ).innerHTML = newString;
			                }
			                catch (e) { alert("line not found!!!!!!!!11111"); }
					}
					else
					{
						//Check if the cursor selection has anything. 
						if(tempCurrentLine[1] == ""){tempCurrentLine[1] = "<span id='cursor'> </span>";}
						else
						{
                 			tempCurrentLine[1] = "<span id='cursor'>" + tempCurrentLine[1] + "</span>";
						}
						
                		try 
						{
                   			guiDoc.getElementById( XPODoc.getLineId(cursorLine) ).innerHTML = tempCurrentLine.join("");
                		}
	            		catch (e) { alert("line not found!!!!!!!!!!11111"); }
					}
			
	       // Update the GUI with the correct line and col
	       displayCursorPos();
	
}

/* Replace some things like tabs, spaces, < and > */
//function replaceHTMLEntities( paramText ) {
//	paramText = paramText.replace(/&/g, "&amp;"); // Leave this one first.
//	paramText = paramText.replace(/>/g, "&gt;");
//	paramText = paramText.replace(/</g, "&lt;");
///	paramText = paramText.replace(/ /g, "&nbsp;");	
//	paramText = paramText.replace(/\//g, "&#47;");
//	paramText = paramText.replace(/\\/g, "&#92;");
//	paramText = paramText.replace(/\t/g,"&nbsp;&nbsp;&nbsp;&nbsp;");
//	return paramText;
//}

/* This function (re-)renders the entire document */
function refreshDocument() {
	var myDoc = guiDoc.getElementById("entireDocument");
	while ( myDoc.firstChild ) {
		myDoc.removeChild( myDoc.firstChild );
	}
	
	for(var l=0; l < XPODoc.document.length; l++ ){
		var newLine = guiDoc.createElement('div');
		newLine.setAttribute('id', XPODoc.getLineId(l) );
		newLine.setAttribute('class', "line");		// RELATED TO FIX OF ISSUE #1 >> See DEVLOG.TXT is
		myDoc.appendChild( newLine );				
		if ( l == cursorLine ) {/*renderCursor();*/;}
		else ;//clearFormatting( l );
	}
}


// This function will perform auto-scrolling of the iFrame to keep the cursor in view at all times
function adjustScroll() {
	// TODO: COMMENT THIS FUNCTION
	var frameWidth;
	var frameHeight;
	if(isIE == true){
		frameWidth = guiDoc.body.clientWidth;
		frameHeight = guiDoc.body.clientHeight;
	}
	else{
		frameWidth = myIFrame.contentWindow.innerWidth;
		frameHeight = myIFrame.contentWindow.innerHeight;
	}

	//var frameWidth = myIFrame.contentWindow.innerWidth;
	//var frameHeight = myIFrame.contentWindow.innerHeight;
	var cursorDocOffsetX = (cursorColumn*FONT_WIDTH) + PADDING_LEFT;
	var cursorDocOffsetY = (cursorLine*FONT_HEIGHT) + PADDING_TOP;
	var visibleEdgeX = getScrollOffsetX()+frameWidth-FONT_WIDTH;
	var visibleEdgeY = getScrollOffsetY()+frameHeight-FONT_HEIGHT;
	var scrollAmountX=0;
	var scrollAmountY=0;
	
	if (cursorDocOffsetX>visibleEdgeX) scrollAmountX=cursorDocOffsetX-visibleEdgeX+100;
	else if (cursorDocOffsetX<getScrollOffsetX()) scrollAmountX=cursorDocOffsetX-getScrollOffsetX()-100;
	if (cursorDocOffsetY>visibleEdgeY) scrollAmountY=cursorDocOffsetY-visibleEdgeY+100;
	else if (cursorDocOffsetY<getScrollOffsetY()) scrollAmountY=cursorDocOffsetY-getScrollOffsetY()-100;
	
	if(isIE == true) myIFrame.scrollBy(scrollAmountX, scrollAmountY);
	else myIFrame.contentWindow.scrollBy(scrollAmountX, scrollAmountY);
}


/**********************************************/
/****** DOCUMENT SYNCHRONIZATION *****/

// This will be an 'update' that we will send to the server
function updateObject(paramAction, paramText, paramLineNum){
	this.action = paramAction;
	this.text = paramText;
	this.lineNum = paramLineNum;
	this.documentID = XPODoc.documentID;
}

// we might want to move this into the document
var pendingServerUpdates = new Array();

// paramAction: i (insert), u (update), d (delete)
// paramText: the new text for the affected line
// paramLineNum: the line where the action will take place
function updateDocument( paramAction, paramText, paramLineNum ) {
	// Fix the line locks
	if(paramAction == "i" || paramAction == "d"){
		for( var i=0; i < lockedLines.length; i++ )
		{			
			if(paramAction == "i" && lockedLines[i].lineID > paramLineNum){
				lockedLines[i].lineID = parseInt(lockedLines[i].lineID) + 1;
			}
			else if(paramAction == "d" && lockedLines[i].lineID > paramLineNum){
				lockedLines[i].lineID = parseInt(lockedLines[i].lineID) - 1;
			}
		}
	}
	
	// Replace any ampersands or plus signs for transmission...	
	paramText = paramText.replace(/&/g, "aMPerSand");
	paramText = paramText.replace(/\+/g, "pLUsSign");
	
	// If we have multiple updates to the same line in a row, just use the latest one.
	var arrayLength = pendingServerUpdates.length;
	if(arrayLength > 0){
		var lastUpdateObj = pendingServerUpdates[ arrayLength-1 ];
		if(lastUpdateObj.action == "u" && paramAction == "u" && lastUpdateObj.lineNum == paramLineNum){
			pendingServerUpdates[ arrayLength-1 ] = new updateObject(paramAction, paramText, paramLineNum);
			return;
		}
	}
	pendingServerUpdates.push( new updateObject(paramAction, paramText, paramLineNum) );
}

setTimeout('sendDocumentUpdates()',5000);

function sendDocumentUpdates(){

	if(pendingServerUpdates.length > 0){
	//alert(pendingServerUpdates.toJSON());
		new Ajax.Request('./handlers/documentUpdate.php?', {
			method:'post',
			postBody: 'updateData='+pendingServerUpdates.toJSON(),
			onSuccess: function(transport) {
				if(transport.responseText != ""){
					//alert(transport.responseText);
				}
			}		
		});
		
		// Clear out the array so it doesn't send again.  We should probably also keep a record somewhere of them for awhile
		pendingServerUpdates  = new Array();
	}
	
	// Every 1 second, see if there is anything to send again
	setTimeout('sendDocumentUpdates()', 1000);
}

function updateLineLock( line ) {
	new Ajax.Request('./documents/lineLock/updateLineLock.php?curLine='+line+'&docID='+XPODoc.documentID, {
		method:'get'		
	});
}



/*************************************************/
/******* INITIALIZATION / LOAD FUNCTIONS *****/

function init() {
	/* Get handle on main document object */
	mainDoc = document;	
	
	/* BROWSER DETECTION */
	var ua = navigator.userAgent.toLowerCase();	
	isFF = (ua.indexOf("firefox") != -1);
	isIE = (ua.indexOf("msie") != -1);
	isChrome = (ua.indexOf("chrome") != -1);
	isSafari = (ua.indexOf("safari") != -1) && (ua.indexOf("chrome") == -1);
	
	/* Get browser-dependent handle on the iFrame and the iFrame's content document */
	if(isIE == false) myIFrame = document.getElementById("myI");
	else myIFrame = frames["myI"];
	
	/* Get handle on iFrame's content document */
	if(isIE == true) guiDoc = myIFrame.document;
	else guiDoc = myIFrame.contentWindow.document;
		
	/* Initialize our text document data structure */
	XPODoc = new TextDocument( guiDoc );
}

/* This function is responsible for (re-)initializing the text data structure, given a document ID, text, and setting the access mode */
function loadNewDoc(docID, docText, accessMode) {
	/* Ensure that the text data structure is clean  */
	// NOTE:  Couldn't we instead, simply do:  XPODoc = new TextDocument();  ????  Would that be less efficient?
	XPODoc.blankDocument();
	XPODoc.documentID = docID;
	
	/* Populate the XPODoc data structure */
	XPODoc.insertText(docText);
	
	/* Set the access mode.  If not readonly, it shall be assume read-write */
	readOnly = (accessMode == "r");
	
	/* Add event listeners, but only if the mode is read-write (NOT readOnly) */
	if(readOnly == false){
		if(isIE == true || isChrome == true || isSafari == true){
			guiDoc.onclick = onClickFunction;
			guiDoc.onkeypress = onKeyPressFunction;
			guiDoc.onkeydown = onKeyDownFunction;
		}
		else{
			guiDoc.addEventListener("click", onClickFunction, true);
			guiDoc.addEventListener("keydown", onKeyDownFunction, true);
			guiDoc.addEventListener("keypress", onKeyPressFunction, true);
		}
	}
	else{ // Remove event listeners because we are in readOnly mode
		if(isIE == true || isChrome == true || isSafari == true){
			guiDoc.onclick = null;
			guiDoc.onkeydown = null;
			guiDoc.onkeypress = null;
		}
		else{
			guiDoc.removeEventListener("click", onClickFunction, true);
			guiDoc.removeEventListener("keydown", onKeyDownFunction, true);
			guiDoc.removeEventListener("keypress", onKeyPressFunction, true);
		}
	}
	
	/* Ensure that the text 'window' has the focus, thus allowing immediate editing (if eventListeners are active, of course) */
	giveDocumentFocus();
	
	/* Initialize the cursor to the starting position */
	setCursor(0,0);
	
	/* Render the entire document */
	XPODoc.renderEntireDocument();
}



/***************************************************/
/*********** EVENT HANDLER FUNCTIONS ***********/

/* This function is the handler for the onclick event. */
onClickFunction = function( paramEvent ){
	XPODoc.setLineUpdated( cursorLine );
	var oldCursorLine = cursorLine;

	captureMousePos(paramEvent);
	deriveCursorForDocument(mouseX,mouseY,XPODoc);
	if(oldCursorLine != cursorLine) {
		XPODoc.setLineUpdated( cursorLine );
		updateLineLock(cursorLine);
	}
	XPODoc.renderUpdates( cursorLine, cursorColumn );
}

/* This function is the handler of the keydown event.  Mainly, this function will execute the typeSpecial function */
onKeyDownFunction = function( paramEvent ) {
	XPODoc.setLineUpdated( cursorLine );
	var oldCursorLine = cursorLine;
	
	// Determine the keyCode of the pressed key (browser-dependent implementation)
	var key;
	var isShift;
	var isAlt;
	var isCtl;
	if(isIE == true){ 
		key = myIFrame.window.event.keyCode;
		isShift = myIFrame.window.event.shiftKey;
		isAlt = myIFrame.window.event.altKey;
		isCtl = myIFrame.window.event.ctrlKey;
	}
	else{ 
		key = paramEvent.keyCode;
		isShift = paramEvent.shiftKey;
		isAlt = paramEvent.altKey;
		isCtl = paramEvent.ctrlKey;
	}

	// if typeSpecial actually does something, it returns false...
	var returnValue = typeSpecial( XPODoc, key, isAlt, isCtl, isShift );

	XPODoc.setLineUpdated( cursorLine );
	
	if(oldCursorLine != cursorLine) {
		XPODoc.setLineUpdated( cursorLine );
		updateLineLock(cursorLine);
	}
	XPODoc.renderUpdates( cursorLine, cursorColumn );
	
	adjustScroll();
	
	return returnValue;	//  ... and if typeSpecial returns false, we don't want the event to bubble, so pass this return value along
}


/* This function is the handler for the keypress event.  Mainly, this function will execute the typeCharacter function, if applicable */
onKeyPressFunction = function( paramEvent ){
	var oldCursorLine = cursorLine;
	
	// Determine the ASCII code of the to-be-typed character (browser-dependent implementation)
	var key;
	if(isFF == true) key = paramEvent.charCode;
	else if(isIE == true) key = myIFrame.window.event.keyCode;
	else if(isChrome == true || isSafari == true) key = paramEvent.keyCode;
	else alert('an unknown browser... editing may not work.');

	// If a valid character (nonzero), then type it
	if ( key != 0 ) typeCharacter( XPODoc, key );
	
	if(oldCursorLine != cursorLine) {
		updateLineLock(cursorLine);
	}
	XPODoc.renderUpdates( cursorLine, cursorColumn );
}

/* This function is the handler of the mousedown event */
onMouseDownFunction = function( paramEvent ) {
	if(isIE == true || isChrome == true || isSafari == true){
		guiDoc.onmousemove = onMouseMoveFunction;
	}
	else{
		guiDoc.addEventListener("mousemove", onMouseMoveFunction, true);
	}
	
	
}
/* This function is the handler of the mouseup event */
onMouseUpFunction = function( paramEvent ) {
	// Remove the onMouseMove event listener to avoid performance death...
	if(isIE == true || isChrome == true || isSafari == true){
		guiDoc.onmousemove = null;
	}
	else{
		guiDoc.removeEventListener("mousemove", onClickFunction, true);
	}
}
/* This function is the handler of the mousemove event */
/* NOTE:  THE HANDLER FOR THIS FUNCTION SHOULD NOT BE */
/* REGISTERED UNLESS NEEDED!!  THIS FUNCTION KILLS PERFORMANCE OTHERWISE */
onMouseMoveFunction = function( paramEvent ) {
	// Remember original cursor position
	var oldCursorLine = cursorLine;
	var oldCursorColumn = cursorColumn;
	
	// Determine which position the mouse is in
	captureMousePos(paramEvent);
	deriveCursorForDocument(mouseX,mouseY,XPODoc);
	
	// Check if we are already in select mode or not:
	// If we are already in select-mode...
	if ( isSelectMode ) {
		// Determine if the mouse has moved enough to require re-rendering of the line
		// If so, flag the line(s) for rendering.  Otherwise, do nothing.
		if ( oldCursorLine != cursorLine ) {
			XPODoc.setLineUpdated( oldCursorLine );
			XPODoc.setLineUpdated( cursorLine );
		}
		else if ( oldCursorColumn != cursorColumn ) {
			XPODoc.setLineUpdated( cursorLine );
		}
	}
	// If not already in select-mode...
	else {
		// Determine if the mouse has moved enough to start a selection
		// If so, enable selection mode.  (Otherwise, do nothing)
		if ( oldCursorLine != cursorLine || oldCursorColumn != cursorColumn ) {
			setSelectMode( oldCursorLine, oldCursorColumn );
		}
	}
}
</script>
<iframe id="myI" name="myI" src="./editor/editableContent.html" style="width:100%;height:100%;"></iframe>