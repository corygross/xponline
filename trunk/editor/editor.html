<script type="text/javascript" charset="utf-8" src="tokensearch.js"></script>
<script type="text/javascript" charset="utf-8" src="writeSpans.js"></script>
<script type="text/javascript" charset="utf-8" src="editor/TextDocumentClass.js"></script>
<script type="text/javascript" charset="utf-8" src="editor/userInputLogic.js"></script>
<script type="text/javascript">

/**********************************************/
/********** DECLARE GLOBAL VARIABLES **********/

// Browser(HTML) document related globals
var myIFrame;
var mainDoc;

// Browser specific
var isFF;
var isIE;
var isChrome;
var isSafari;

// CSS related constants
var FONT_WIDTH = 8;
var FONT_HEIGHT = 17;
var PADDING_TOP = 8;
var PADDING_LEFT = 8;

// Text document container
var XPODoc;

// Text-editing related global flags (to be treated as BOOLEAN variables)
var isShiftDown;
var isCtlDown;
var isAltDown;

// Other stuff
var readOnly = true;
var syntaxHighlightOn = true;
var lockedLines = new Array();

// HTML-DOM handle for document pane
var guiDoc;


// This function does a raw capture of mouse position, given an event
function captureMousePos(e) {
	if(isIE == true){
		//this is cory's attempt... its not perfect, but it shows how you can do it
		e = myIFrame.window.event;
		mouseX = e.clientX + guiDoc.body.scrollLeft - 3;
        mouseY = e.clientY + guiDoc.body.scrollTop - 3;
	}
	else{
		mouseX = e.pageX;
		mouseY = e.pageY;
	}
}

function getScrollOffsetX() {
	if(isIE == true){
		return guiDoc.body.scrollLeft;
	}
	else{
		return myIFrame.contentWindow.pageXOffset;
	}
}
function getScrollOffsetY() {
	if(isIE == true){
		return guiDoc.body.scrollTop;
	}
	else{
		return myIFrame.contentWindow.pageYOffset;
	}
}



/**********************************************/
/******** USER INPUT RELATED FUNCTIONS ********/

// This function inserts a bookmark into the document and displays it
function insertBookmark( paramBMtext ) {
	if( XPODoc.getLineText( cursorLine ).trim() == "" ){
		XPODoc.setLineText( cursorLine, paramBMtext );
		clearFormatting( cursorLine );
		renderCursor();
	}
	else{
		XPODoc.insertLine( cursorLine+1, XPODoc.getLineText( cursorLine ) );
		XPODoc.setLineText( cursorLine, paramBMtext );

		// TODO: FIXME: HACK:  Need to make the above change visible in the GUI
		// The following lines are very similar to the code in ENTER
		clearFormatting( cursorLine );
		var myDoc = guiDoc;
		var addMe = myDoc.createElement('div');
		addMe.setAttribute('id', XPODoc.getLineId( cursorLine+1 ) );
		addMe.setAttribute('class', "line");
		myDoc.getElementById("entireDocument").insertBefore( addMe, myDoc.getElementById( XPODoc.getLineId( cursorLine+2 ) ) );
		
		cursorLine++;
		cursorColumn = 0;
		
		renderCursor();
	}
}

// This function is responsible for recalculating the cursor position
// after a command to move the cursor has been issued. It takes as a 
// parameter a DIRECTION, of which valid values are defined above in
// the global variable declarations
function typeSpecial(paramKEYCODE) {

	switch ( paramKEYCODE ) {
	
		case LEFTARROWKEY: 
			// If we are at the first char of the first line do nothing
			// If we are at the first char of any other line, wrap to the last char of the previous line
			// Otherwise, simply move left
			if ( cursorColumn == 0 && cursorLine == 0 ) break;
			if ( cursorColumn == 0 ) {
				cursorLine--;
				cursorColumn = XPODoc.getLineLength(cursorLine)-1;
			}
			else cursorColumn--;			
			break;
			
		case RIGHTARROWKEY:
			// If we are at the last char of the last line, do nothing
			// If we are at the last char of any other line, wrap to the first char of the next line
			// Otherwise, simply move right
			if ( cursorColumn == XPODoc.getLineLength(cursorLine)-1 && cursorLine == XPODoc.getDocumentLength()-1 ) break;
			if ( cursorColumn == XPODoc.getLineLength(cursorLine)-1 ) {
				cursorLine++;
				cursorColumn = 0;
			}
			else cursorColumn++;
			break;
			
		case UPARROWKEY:
			// If we are on the first line, move to first char of line.
			// Otherwise, move up. If we end up out of range of the line, move to the last char of the line
			if ( cursorLine == 0 ) cursorColumn = 0;
			else if ( cursorColumn > XPODoc.getLineLength(--cursorLine) ) cursorColumn = XPODoc.getLineLength(cursorLine)-1;
			break;
			
		case DOWNARROWKEY:
			// If we are on the last line, move to last char of line.
			// Otherwise, move down. If we end up out of range of the line, move to the last char of the line
			if ( cursorLine == XPODoc.getDocumentLength()-1 ) cursorColumn = XPODoc.getLineLength(cursorLine)-1;
			else if ( cursorColumn > XPODoc.getLineLength(++cursorLine) ) cursorColumn = XPODoc.getLineLength(cursorLine)-1;
			break;
			
		case ENDKEY:
			// Move to the last char of the current line
			cursorColumn = XPODoc.getLineLength(cursorLine)-1;
			break;
			
		case HOMEKEY:
			// Move to the first char of the current line
			cursorColumn = 0;
			
		case PAGEUPKEY:
			// Move the cursor up a number of time relative to the current editing window's height			
			if(isIE == true){
				cursorLine -= Math.floor(guiDoc.body.clientHeight / FONT_HEIGHT);
			}
			else{
				cursorLine -= Math.floor(myIFrame.contentWindow.innerHeight / FONT_HEIGHT);
			}
			// Do out-of-bounds checks
			if ( cursorLine < 0 ) {
				cursorLine = 0;
				cursorColumn = 0;
			} else if ( cursorColumn >= XPODoc.getLineLength( cursorLine ) ) cursorColumn = XPODoc.getLineLength(cursorLine)-1;
			if(isIE == true){
				myIFrame.scrollBy(0,-guiDoc.body.clientHeight+PADDING_TOP);
			}
			else{
				myIFrame.contentWindow.scrollBy(0,-myIFrame.contentWindow.innerHeight+PADDING_TOP);
			}
			break;
					
		case PAGEDOWNKEY:
			// Move the cursor down a number of times relative to the current editing window's height
			if(isIE == true){
				cursorLine += Math.floor(guiDoc.body.clientHeight / FONT_HEIGHT);
			}
			else{
				cursorLine += Math.floor(myIFrame.contentWindow.innerHeight / FONT_HEIGHT);
			}
			// Do out-of-bounds checks
			if ( cursorLine > XPODoc.getDocumentLength()-1 ) {
				cursorLine = XPODoc.getDocumentLength()-1;
				cursorColumn = XPODoc.getLineLength( cursorLine )-1;
			} else if ( cursorColumn >= XPODoc.getLineLength( cursorLine ) ) cursorColumn = XPODoc.getLineLength(cursorLine)-1;
			if(isIE == true){
				myIFrame.scrollBy(0,guiDoc.body.clientHeight-PADDING_TOP);
			}
			else{
				myIFrame.contentWindow.scrollBy(0,myIFrame.contentWindow.innerHeight-PADDING_TOP);
			}
			break;
			
		case BACKSPACEKEY:
			// If we are on the first char of the first line, do nothing.
			// If we are on the first char of any other line, backspace removes the "newline character"
			// -- which doesn't exist in our implementation.  We simulate this removal by merging lines.
			// Otherwise, we simply remove the previous char in the current line
			if ( cursorLine == 0 && cursorColumn == 0 ) break;
			if ( cursorColumn == 0 ) {
				// Merge the two lines, and remove the original line
				cursorColumn = XPODoc.getLineLength( cursorLine-1 );	// Place cursor at end of prior line
				// Perform text merge into prior line
				XPODoc.setLineText( cursorLine-1, XPODoc.getLineText( cursorLine-1 ) + XPODoc.getLineText( cursorLine ) );
				
				// FIXME: HACK:  BAD FORM!  The following lines promote tight coupling between GUI and backend!  ARRRGGGGHHHHH! 
				var removeMe = guiDoc.getElementById(XPODoc.getLineId( cursorLine ));
				removeMe.parentNode.removeChild(removeMe);
				
				// Remove the line from our data structure
				XPODoc.removeLine( cursorLine );
				// Decrement cursorLine
				cursorLine--;
			} else {
				// "Remove" the character prior to cursorColumn, and decrement cursorColumn
				var tempText = XPODoc.getLineText( cursorLine );
				XPODoc.setLineText( cursorLine, tempText.substring(0,cursorColumn-1) + tempText.substring(cursorColumn--) );
			}
			break;
			
		case DELETEKEY:
			// If we are at the last char of the last line, do nothing
			// If we are at the last char of any other line, we remove the 'newline character', thus merging the current line with the next line
			// Otherwise, we simply remove the char at the cursor position
			if ( cursorColumn == XPODoc.getLineLength( XPODoc.getDocumentLength()-1 )-1 && cursorLine == XPODoc.getDocumentLength()-1 ) break;
			if ( cursorColumn == XPODoc.getLineLength( cursorLine )-1 ) {
				// Merge the next line into the current line
				XPODoc.setLineText( cursorLine, XPODoc.getLineText(cursorLine) + XPODoc.getLineText(cursorLine+1) );
				
				// FIXME: HACK:  BAD FORM!  The following lines promote tight coupling between GUI and backend!  ARRRGGGGHHHHH! 
				var removeMe = guiDoc.getElementById(XPODoc.getLineId( cursorLine+1 ));
				removeMe.parentNode.removeChild(removeMe);
				
				// Remove the line in question from our data structure
				XPODoc.removeLine( cursorLine+1 );
			} else {
				// "Remove" the character at the cursorColumn position
				var tempText = XPODoc.getLineText( cursorLine );
				XPODoc.setLineText( cursorLine, tempText.substring(0,cursorColumn) + tempText.substring(cursorColumn+1) );
			}
			break;
			
		case ENTERKEY:
			// When we press the enter key, we need to insert a new line into the document
			// We need to insert a new line following the current line, which contains the current line's text starting from the cursor
			XPODoc.insertLine( cursorLine+1, XPODoc.getLineText( cursorLine ).substring( cursorColumn ) );
			XPODoc.setLineText( cursorLine, XPODoc.getLineText( cursorLine ).substring( 0, cursorColumn ) );

			// TODO: FIXME: HACK:  Need to make the above change visible in the GUI
			clearFormatting( cursorLine );
			var myDoc = guiDoc;
			var addMe = myDoc.createElement('div');
			addMe.setAttribute('id', XPODoc.getLineId( cursorLine+1 ) );
			addMe.setAttribute('class', "line");
			myDoc.getElementById("entireDocument").insertBefore( addMe, myDoc.getElementById( XPODoc.getLineId( cursorLine+2 ) ) );
				
			cursorLine++;
			cursorColumn = 0;
			break;
			
		case TABKEY:
			// Insert 4 spaces at current cursor position
			//  SUPER HACK:  Need to redesign functions a bit to eliminate redundancy and make it cleaner and more readable.  
			// We eventually want this to call an "insertText()" function, but for now....
			typeCharacter(" ".charCodeAt(0), XPODoc );
			typeCharacter(" ".charCodeAt(0), XPODoc );
			typeCharacter(" ".charCodeAt(0), XPODoc );
			typeCharacter(" ".charCodeAt(0), XPODoc );
			break;
		case SHIFTKEY:
		
			break;
		case CAPSLOCKKEY:
			
			break;
		//case SPACEKEY:
		//	typeCharacter(" ".charCodeAt(0), XPODoc );
		//	break;
		default:
			return false;
	}
	return true;
} // END typeSpecial(paramKEY)

function getCharCode( paramKey, paramShiftPressed ){

	if(paramShiftPressed){
		if(paramKey >= 65 && paramKey <= 90) //A-Z a-z
			return paramKey;
		else if(paramKey == 49) // 1 !
			return 33;
		else if(paramKey == 50) // 2 @
			return 64;
		else if(paramKey == 51) // 3#
			return 35;
		else if(paramKey == 52) // 4$
			return 36;
		else if(paramKey == 53) // 5%
			return 37;
		else if(paramKey == 54) // 6^
			return 94;
		else if(paramKey == 55) // 7&
			return 38;
		else if(paramKey == 56) // 8*
			return 42;
		else if(paramKey == 57) // 9(
			return 40;
		else if(paramKey == 48) // 0)
			return 41;
		else if(paramKey == 186) // :
			return 58;
		else if(paramKey == 187) // +
			return 43;
		else if(paramKey == 188) // <
			return 60;
		else if(paramKey == 189) // _
			return 95;
		else if(paramKey == 190) // >
			return 62;
		else if(paramKey == 191) // ?
			return 63;
		else if(paramKey == 192) // ~
			return 126;
		else if(paramKey == 219) // {
			return 123;
		else if(paramKey == 220) // |
			return 124;
		else if(paramKey == 221) // }
			return 125;
		else if(paramKey == 222) // "
			return 34;
	}
	else{
		if(paramKey >= 65 && paramKey <= 90) //a-z
			return paramKey + 32;
		else if(paramKey >= 48 && paramKey <= 57) //0-9
			return paramKey;
		else if(paramKey == 186) // ;
			return 59;
		else if(paramKey == 187) // =
			return 61;
		else if(paramKey == 188) // ,
			return 44;
		else if(paramKey == 189) // -
			return 45;
		else if(paramKey == 190) // .
			return 46;
		else if(paramKey == 191) // /
			return 47;
		else if(paramKey == 192) // `
			return 96;
		else if(paramKey == 219) // [
			return 91;
		else if(paramKey == 220) // \
			return 92;
		else if(paramKey == 221) // ]
			return 93;
		else if(paramKey == 222) // '
			return 39;		
	}
	return null;
}



/**********************************************/
/**** GUI RELATED / GUI SPECIFIC FUNCTIONS ****/

// This function displays the cursor position in the GUI
function displayCursorPos() {
	updateLineCol(cursorLine, cursorColumn);
}

// This function clears the formatting of the line specified by paramLineNumber
function clearFormatting( paramLineNum ) {
	if(guiDoc.getElementById( XPODoc.getLineId(paramLineNum) ) != null){
		//guiDoc.getElementById( XPODoc.getLineId(paramLineNum) ).innerHTML = XPODoc.getLineText(paramLineNum);

		//RT - NOT SURE WHAT THIS DOES....
		//Parses the contents of each line for syntax hightlighting.
		guiDoc.getElementById( XPODoc.getLineId(paramLineNum) ).innerHTML = indexLineText(XPODoc.getLineText(paramLineNum));
	}
}

// This function clears the old cursor and moves to the line specified by paramLineNumber
function gotoLine( paramLineNum ) {
	clearFormatting(cursorLine);
	cursorLine = paramLineNum;
	cursorColumn = 0;
	renderCursor();
	adjustScroll();
}

// This function clears the old cursor and moves to the line specified by paramLineNumber
function gotoPosition( paramLineNum, paramColNum ) {
	clearFormatting(cursorLine);
	cursorLine = paramLineNum;
	cursorColumn = paramColNum;
	renderCursor();
	adjustScroll();
}

// This function takes each line of input and applies formatting based on keywords
function indexLineText(inputText)
{
//	alert("beginning of indexLineText function");

	if(!syntaxHighlightOn){ return inputText; }
	
	var testArr = new Array("public", "static", "void");
	var words = inputText.split(" ");
	
	//Change the document css to the applicable language css
	//HERE!
	
	var newLine = "";
//	alert("enter for loop");
	for(var counter = 0; counter < words.size(); counter++)
	{	
			var curWord = words[counter];
		//If the current word is one that needs to be highlighted	
		if(tokenSearch(curWord))
		//if(testArr.indexOf(words[count]) != -1)
		{
			// This regex probably should be global, but I am testing - CG
			// If the 'word' is a number, highlight it with the class 'number'
//			var IsNum = /^-?\d+$/.test(words[count]);
//			if(IsNum == true){
//				alert("found one");
//			var markedWord = "<span class='" + curWord + "'>" + curWord + "</span>";
			var markedWord = writeSpans(curWord);
			
				newLine += markedWord + " ";
			//}
		}
			else
			{
//				alert("nothing");
				newLine += curWord + " ";
			}
		}
//		alert("exit for loop");
	return newLine;
}

// This function highlights and locks lines given by the 'newLineLocks' array it receives
function lockLines( newLineLocks ) {
	// Clear the old line locks
	for( var i=0; i < lockedLines.length; i++ )
	{
		clearFormatting( lockedLines[i] );
	}
	// Add the new line locks
	for( var j=0; j < newLineLocks.length; j++ )
	{
		guiDoc.getElementById( XPODoc.getLineId(newLineLocks[j]) ).innerHTML = "<font style='BACKGROUND-COLOR: orange'>" + XPODoc.getLineText(newLineLocks[j]) + "</font>";
	}
	lockedLines = newLineLocks;
}

// This function renders the cursor in the document. 
function renderCursor() {
		// Slice 'n dice the line to isolate the cursor
		var tempCurrentLine = new Array();
		
		tempCurrentLine.push(XPODoc.getLineText(cursorLine).substring(0,cursorColumn));
		tempCurrentLine.push(XPODoc.getLineText(cursorLine).substr(cursorColumn, 1));
		tempCurrentLine.push(XPODoc.getLineText(cursorLine).substring(cursorColumn+1));

		// Apply formatting
		tempCurrentLine[1] = "<span id='cursor'>" + tempCurrentLine[1] + "</span>";

		//Re render any syntax highlighting that may be there
		var formatted = indexLineText(tempCurrentLine[0] + tempCurrentLine[1] + tempCurrentLine[2]);
	
		// display new formatting
		try {
			//guiDoc.getElementById( XPODoc.getLineId(cursorLine) ).innerHTML = tempCurrentLine.join("");
			guiDoc.getElementById( XPODoc.getLineId(cursorLine) ).innerHTML = formatted;
			//guiDoc.getElementById( XPODoc.getLineId(cursorLine) ).innerHTML = indexLineText(tempCurrentLine.join(""));
		}
		catch (e) { alert("line not found!"); }

		// Update the GUI with the correct line and col
		displayCursorPos();
}

// This function (re-)renders the entire document
function refreshDocument() {
	var myDoc = guiDoc.getElementById("entireDocument");
	while ( myDoc.firstChild ) {
		myDoc.removeChild( myDoc.firstChild );
	}
	
	for(var l=0; l < XPODoc.document.length; l++ ){
		var newLine = guiDoc.createElement('div');
		newLine.setAttribute('id', XPODoc.getLineId(l) );
		newLine.setAttribute('class', "line");		// RELATED TO FIX OF ISSUE #1 >> See DEVLOG.TXT is
		myDoc.appendChild( newLine );				
		if ( l == cursorLine ) {renderCursor();}
		else clearFormatting( l );
	}
}

// This function toggles whether or not syntax highlighting is on
function toggleSyntaxHighlight() 
{
	syntaxHighlightOn = !syntaxHighlightOn;
	refreshDocument();
}

// This function will perform auto-scrolling of the iFrame to keep the cursor in view at all times
function adjustScroll() {
	// TODO: COMMENT THIS FUNCTION
	var frameWidth;
	var frameHeight;
	if(isIE == true){
		frameWidth = guiDoc.body.clientWidth;
		frameHeight = guiDoc.body.clientHeight;
	}
	else{
		frameWidth = myIFrame.contentWindow.innerWidth;
		frameHeight = myIFrame.contentWindow.innerHeight;
	}

	//var frameWidth = myIFrame.contentWindow.innerWidth;
	//var frameHeight = myIFrame.contentWindow.innerHeight;
	var cursorDocOffsetX = (cursorColumn*FONT_WIDTH) + PADDING_LEFT;
	var cursorDocOffsetY = (cursorLine*FONT_HEIGHT) + PADDING_TOP;
	var visibleEdgeX = getScrollOffsetX()+frameWidth-FONT_WIDTH;
	var visibleEdgeY = getScrollOffsetY()+frameHeight-FONT_HEIGHT;
	var scrollAmountX=0;
	var scrollAmountY=0;
	
	if (cursorDocOffsetX>visibleEdgeX) scrollAmountX=cursorDocOffsetX-visibleEdgeX+100;
	else if (cursorDocOffsetX<getScrollOffsetX()) scrollAmountX=cursorDocOffsetX-getScrollOffsetX()-100;
	if (cursorDocOffsetY>visibleEdgeY) scrollAmountY=cursorDocOffsetY-visibleEdgeY+100;
	else if (cursorDocOffsetY<getScrollOffsetY()) scrollAmountY=cursorDocOffsetY-getScrollOffsetY()-100;
	
	if(isIE == true){
		myIFrame.scrollBy(scrollAmountX, scrollAmountY);
	}
	else{
		myIFrame.contentWindow.scrollBy(scrollAmountX, scrollAmountY);
	}
}


/**********************************************/
/****** DOCUMENT SYNCHRONIZATION *****/

function updateLineLock( line ) {
	new Ajax.Request('./documents/lineLock/updateLineLock.php?curLine='+line+'&docID='+XPODoc.documentID, {
		method:'get'		
	});
}


/********************************************/
/********** INITIALIZATION FUNCTION *********/
function init() {
	/* Get handle on main document object */
	mainDoc = document;	
	
	/* BROWSER DETECTION */
	var ua = navigator.userAgent.toLowerCase();	
	isFF = (ua.indexOf("firefox") != -1);
	isIE = (ua.indexOf("msie") != -1);
	isChrome = (ua.indexOf("chrome") != -1);
	isSafari = (ua.indexOf("safari") != -1) && (ua.indexOf("chrome") == -1);
	
	/* Get browser-dependent handle on the iFrame and the iFrame's content document */
	if(isIE == false) myIFrame = document.getElementById("myI");
	else myIFrame = frames["myI"];
		
	/* Initialize our text document data structure */
	XPODoc = new TextDocument();
}

function loadNewDoc(docID, docText, accessMode) {
	/* Ensure that the text data structure is clean  */
	// NOTE:  Couldn't we instead, simply do:  XPODoc = new TextDocument();  ????  Would that be less efficient?
	XPODoc.blankDocument();
	XPODoc.documentID = docID;
	
	/* Populate the XPODoc data structure */
	var textArr = docText.split(/\r\n|\r|\n/);
	for(var i=0; i < textArr.length; i++ ) {
		XPODoc.appendLine( textArr[i] );
	}
	
	/* Get handle on iFrame's content document */
	if(isIE == true) guiDoc = myIFrame.document;
	else guiDoc = myIFrame.contentWindow.document;
	
	/* Set the access mode.  If not readonly, it shall be assume read-write */
	readOnly = (accessMode == "r");
	
	/* Add event listeners, but only if the mode is read-write (NOT readOnly) */
	if(readOnly == false){
		if(isIE == true || isChrome == true || isSafari == true){
			guiDoc.onclick = onClickFunction;
			//guiDoc.onkeydown = onKeyDownFunction;
			guiDoc.onkeypress = onKeyPressFunction;
		}
		else{
			guiDoc.addEventListener("click", onClickFunction, true);
			guiDoc.addEventListener("keydown", onKeyDownFunction, true);
			guiDoc.addEventListener("keypress", onKeyPressFunction, true);
		}
	}
	else{ // Remove event listeners because we are in readOnly mode
		if(isIE == true || isChrome == true || isSafari == true){
			guiDoc.onclick = null;
			guiDoc.onkeydown = null;
			guiDoc.onkeypress = null;
		}
		else{
			guiDoc.removeEventListener("click", onClickFunction, true);
			guiDoc.removeEventListener("keydown", onKeyDownFunction, true);
			guiDoc.removeEventListener("keypress", onKeyPressFunction, true);
		}
	}
	
	/* Ensure that the text 'window' has the focus, thus allowing immediate editing (if eventListeners are active, of course) */
	if(isIE == true) myIFrame.focus();
	else myIFrame.contentWindow.focus();
	
	/* Initialize the cursor to the starting position */
	setCursor(0,0);
	
	/* Render the entire document */
	refreshDocument();
}

onClickFunction = function( paramEvent ){
	var oldCursorLine = cursorLine;
	clearFormatting(cursorLine);
	captureMousePos(paramEvent);
	deriveCursorForDocument(mouseX,mouseY,XPODoc);
	renderCursor();
	if(oldCursorLine != cursorLine) updateLineLock(cursorLine);
}

onKeyPressFunction = function( paramEvent ){
//alert("keypress");
	var oldCursorLine = cursorLine;
	clearFormatting(cursorLine);
	
	// Determine the ASCII code of the to-be-typed character (browser-dependent implementation)
	var key;
	if(isFF == true) key = paramEvent.charCode;
	else if(isIE == true) key = myIFrame.window.event.keyCode;
	else if(isChrome == true || isSafari == true) key = paramEvent.keyCode;
	else alert('an unknown browser... editing may not work.');

	// If a valid character (nonzero), then type it
	if ( key != 0 ) typeCharacter( key );
	
	renderCursor();
	adjustScroll();
	if(oldCursorLine != cursorLine) updateLineLock(cursorLine);
	return false;
}

onKeyDownFunction = function( paramEvent ) {
//alert("keydown");
	var oldCursorLine = cursorLine;
	clearFormatting(cursorLine);
	
	// Determine the keyCode of the pressed key (browser-dependent implementation)
	var key;
	if(isIE == true) key = myIFrame.window.event.keyCode;
	else key = paramEvent.keyCode;

	typeSpecial( key );
	renderCursor();
	adjustScroll();
	if(oldCursorLine != cursorLine) updateLineLock(cursorLine);
	return false;
}

</script>
<iframe id="myI" name="myI" src="./editor/editableContent.html" style="width:100%;height:100%;"></iframe><br />
