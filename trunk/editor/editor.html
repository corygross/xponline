<script type="text/javascript" charset="utf-8" src="tokensearch.js"></script>
<script type="text/javascript" charset="utf-8" src="writeSpans.js"></script>
<script type="text/javascript" charset="utf-8" src="editor/RendererClass.js"></script>
<script type="text/javascript" charset="utf-8" src="editor/TextDocumentClass.js"></script>
<script type="text/javascript" charset="utf-8" src="editor/userInputLogic.js"></script>
<script type="text/javascript" src="jWords.js"></script>
<script type="text/javascript" charset="utf-8" src = "editor/toggleSH.js"></script>
<script type="text/javascript">

/**********************************************/
/********** DECLARE GLOBAL VARIABLES **********/

// Browser(HTML) document related globals
var myIFrame;
var mainDoc;

// Browser specific
var isFF;
var isIE;
var isChrome;
var isSafari;

// CSS related constants
var FONT_WIDTH = 8;
var FONT_HEIGHT = 17;
var PADDING_TOP = 8;
var PADDING_LEFT = 8;

// Text document container
var XPODoc;

// Text-editing related global flags (to be treated as BOOLEAN variables)
var isShiftDown;
var isCtlDown;
var isAltDown;

// Other stuff
var readOnly = true;
var syntaxHighlightOn = true;
var lockedLines = new Array();

// HTML-DOM handle for document pane
var guiDoc;

/*********** END OF GLOBAL VARIABLES ********/
/**********************************************/

function getDoc(){
	return guiDoc;
}


// This function does a raw capture of mouse position, given an event
function captureMousePos(e) {
	if(isIE == true){
		//this is cory's attempt... its not perfect, but it shows how you can do it
		e = myIFrame.window.event;
		mouseX = e.clientX + guiDoc.body.scrollLeft - 3;
        mouseY = e.clientY + guiDoc.body.scrollTop - 3;
	}
	else{
		mouseX = e.pageX;
		mouseY = e.pageY;
	}
}

/* These two functions return the numeric value for the scroll offset of the iFrame */
function getScrollOffsetX() {
	if(isIE == true) return guiDoc.body.scrollLeft;
	else return myIFrame.contentWindow.pageXOffset;
}
function getScrollOffsetY() {
	if(isIE == true) return guiDoc.body.scrollTop;
	else return myIFrame.contentWindow.pageYOffset;
}



/**************************************************/
/******** USER INPUT RELATED FUNCTIONS ********/

// This function inserts a bookmark into the document and displays it
function insertBookmark( paramBMtext ) {
	if( XPODoc.getLineText( cursorLine ).trim() == "" ){
		XPODoc.setLineText( cursorLine, paramBMtext );
		//clearFormatting( cursorLine );
		//renderCursor();
	}
	else{
		XPODoc.insertLine( cursorLine+1, XPODoc.getLineText( cursorLine ) );
		XPODoc.setLineText( cursorLine, paramBMtext );

		// TODO: FIXME: HACK:  Need to make the above change visible in the GUI
		// The following lines are very similar to the code in ENTER
		//clearFormatting( cursorLine );
		var myDoc = guiDoc;
		var addMe = myDoc.createElement('div');
		addMe.setAttribute('id', XPODoc.getLineId( cursorLine+1 ) );
		addMe.setAttribute('class', "line");
		myDoc.getElementById("entireDocument").insertBefore( addMe, myDoc.getElementById( XPODoc.getLineId( cursorLine+2 ) ) );
		
		cursorLine++;
		cursorColumn = 0;
		
		//renderCursor();
	}
}

/* This function provides functionality to so-called "special keys".  Basically, any non-character related keyboard input. (kindof) */
function typeSpecial(paramKEYCODE, paramIsAlt, paramIsCtl, paramIsShift) {

	switch ( paramKEYCODE ) {
	
		case LEFTARROWKEY: 
			/* If we are holding shift, moving the cursor actually selects text, so we need to ensure we are in select mode */
			if ( paramIsShift ) if ( !isSelectMode ) setSelectMode();
			
			// If we are at the first char of the first line do nothing
			// If we are at the first char of any other line, wrap to the last char of the previous line
			// Otherwise, simply move left
			if ( cursorColumn == 0 && cursorLine == 0 ) break;
			if ( cursorColumn == 0 ) {
				cursorLine--;
				cursorColumn = XPODoc.getLineLength(cursorLine)-1;
			}
			else cursorColumn--;	
			break;
			
		case RIGHTARROWKEY:
			/* If we are holding shift, moving the cursor actually selects text, so we need to ensure we are in select mode */
			if ( paramIsShift ) if ( !isSelectMode ) setSelectMode();
			
			// If we are at the last char of the last line, do nothing
			// If we are at the last char of any other line, wrap to the first char of the next line
			// Otherwise, simply move right
			if ( cursorColumn == XPODoc.getLineLength(cursorLine) && cursorLine == XPODoc.getDocumentLength()-1 ) break;
			if ( cursorColumn == XPODoc.getLineLength(cursorLine) ) {
				cursorLine++;
				cursorColumn = 0;
			}
			else cursorColumn++;
			break;
			
		case UPARROWKEY:
			/* If we are holding shift, moving the cursor actually selects text, so we need to ensure we are in select mode */
			if ( paramIsShift ) if ( !isSelectMode ) setSelectMode();
			
			// If we are on the first line, move to first char of line.
			// Otherwise, move up. If we end up out of range of the line, move to the last char of the line
			if ( cursorLine == 0 ) cursorColumn = 0;
			else if ( cursorColumn > XPODoc.getLineLength(--cursorLine) ) cursorColumn = XPODoc.getLineLength(cursorLine);
			break;
			
		case DOWNARROWKEY:
			/* If we are holding shift, moving the cursor actually selects text, so we need to ensure we are in select mode */
			if ( paramIsShift ) if ( !isSelectMode ) setSelectMode();
			
			// If we are on the last line, move to last char of line.
			// Otherwise, move down. If we end up out of range of the line, move to the last char of the line
			if ( cursorLine == XPODoc.getDocumentLength()-1 ) cursorColumn = XPODoc.getLineLength(cursorLine);
			else if ( cursorColumn > XPODoc.getLineLength(++cursorLine) ) cursorColumn = XPODoc.getLineLength(cursorLine);
			break;
			
		case ENDKEY:
			/* If we are holding shift, moving the cursor actually selects text, so we need to ensure we are in select mode */
			if ( paramIsShift ) if ( !isSelectMode ) setSelectMode();
			
			// Move to the last char of the current line
			cursorColumn = XPODoc.getLineLength(cursorLine);
			break;
			
		case HOMEKEY:
			/* If we are holding shift, moving the cursor actually selects text, so we need to ensure we are in select mode */
			if ( paramIsShift ) if ( !isSelectMode ) setSelectMode();
			
			// Move to the first char of the current line
			cursorColumn = 0;
			break;
			
		case PAGEUPKEY:
			/* If we are holding shift, moving the cursor actually selects text, so we need to ensure we are in select mode */
			if ( paramIsShift ) if ( !isSelectMode ) setSelectMode();
			
			// Move the cursor up a number of time relative to the current editing window's height			
			if(isIE == true){
				cursorLine -= Math.floor(guiDoc.body.clientHeight / FONT_HEIGHT);
			}
			else{
				cursorLine -= Math.floor(myIFrame.contentWindow.innerHeight / FONT_HEIGHT);
			}
			// Do out-of-bounds checks
			if ( cursorLine < 0 ) {
				cursorLine = 0;
				cursorColumn = 0;
			} else if ( cursorColumn >= XPODoc.getLineLength( cursorLine ) ) cursorColumn = XPODoc.getLineLength(cursorLine);
			if(isIE == true){
				myIFrame.scrollBy(0,-guiDoc.body.clientHeight+PADDING_TOP);
			}
			else{
				myIFrame.contentWindow.scrollBy(0,-myIFrame.contentWindow.innerHeight+PADDING_TOP);
			}
			break;
					
		case PAGEDOWNKEY:
			/* If we are holding shift, moving the cursor actually selects text, so we need to ensure we are in select mode */
			if ( paramIsShift ) if ( !isSelectMode ) setSelectMode();
			
			// Move the cursor down a number of times relative to the current editing window's height
			if(isIE == true){
				cursorLine += Math.floor(guiDoc.body.clientHeight / FONT_HEIGHT);
			}
			else{
				cursorLine += Math.floor(myIFrame.contentWindow.innerHeight / FONT_HEIGHT);
			}
			// Do out-of-bounds checks
			if ( cursorLine > XPODoc.getDocumentLength()-1 ) {
				cursorLine = XPODoc.getDocumentLength()-1;
				cursorColumn = XPODoc.getLineLength( cursorLine )-1;
			} else if ( cursorColumn >= XPODoc.getLineLength( cursorLine ) ) cursorColumn = XPODoc.getLineLength(cursorLine);
			if(isIE == true){
				myIFrame.scrollBy(0,guiDoc.body.clientHeight-PADDING_TOP);
			}
			else{
				myIFrame.contentWindow.scrollBy(0,myIFrame.contentWindow.innerHeight-PADDING_TOP);
			}
			break;
			
		case BACKSPACEKEY:
			// If we are on the first char of the first line, do nothing.
			// If we are on the first char of any other line, backspace removes the "newline character"
			// -- which doesn't exist in our implementation.  We simulate this removal by merging lines.
			// Otherwise, we simply remove the previous char in the current line
			if ( cursorLine == 0 && cursorColumn == 0 ) break;
			if ( cursorColumn == 0 ) {
				// Merge the two lines, and remove the original line
				cursorColumn = XPODoc.getLineLength( cursorLine-1 );	// Place cursor at end of prior line
				// Perform text merge into prior line
				XPODoc.setLineText( cursorLine-1, XPODoc.getLineText( cursorLine-1 ) + XPODoc.getLineText( cursorLine ) );
				
				// FIXME: HACK:  BAD FORM!  The following lines promote tight coupling between GUI and backend!  ARRRGGGGHHHHH! 
				//var removeMe = guiDoc.getElementById(XPODoc.getLineId( cursorLine ));
				//removeMe.parentNode.removeChild(removeMe);
				
				// Remove the line from our data structure
				XPODoc.removeLine( cursorLine );
				// Decrement cursorLine
				cursorLine--;
			} else {
				// "Remove" the character prior to cursorColumn, and decrement cursorColumn
				var tempText = XPODoc.getLineText( cursorLine );
				XPODoc.setLineText( cursorLine, tempText.substring(0,cursorColumn-1) + tempText.substring(cursorColumn--) );
			}
			break;
			
		case DELETEKEY:
			// If we are at the last char of the last line, do nothing
			// If we are at the last char of any other line, we remove the 'newline character', thus merging the current line with the next line
			// Otherwise, we simply remove the char at the cursor position
			if ( cursorColumn == XPODoc.getLineLength( XPODoc.getDocumentLength()-1 )-1 && cursorLine == XPODoc.getDocumentLength()-1 ) break;
			if ( cursorColumn == XPODoc.getLineLength( cursorLine )-1 ) {
				// Merge the next line into the current line
				XPODoc.setLineText( cursorLine, XPODoc.getLineText(cursorLine) + XPODoc.getLineText(cursorLine+1) );
				
				// FIXME: HACK:  BAD FORM!  The following lines promote tight coupling between GUI and backend!  ARRRGGGGHHHHH! 
				//var removeMe = guiDoc.getElementById(XPODoc.getLineId( cursorLine+1 ));
				//removeMe.parentNode.removeChild(removeMe);
				
				// Remove the line in question from our data structure
				XPODoc.removeLine( cursorLine+1 );
			} else {
				// "Remove" the character at the cursorColumn position
				var tempText = XPODoc.getLineText( cursorLine );
				XPODoc.setLineText( cursorLine, tempText.substring(0,cursorColumn) + tempText.substring(cursorColumn+1) );
			}
			break;
			
		case ENTERKEY:
			// When we press the enter key, we need to insert a new line into the document
			// We need to insert a new line following the current line, which contains the current line's text starting from the cursor
			XPODoc.insertLine( cursorLine+1, XPODoc.getLineText( cursorLine ).substring( cursorColumn ) );
			XPODoc.setLineText( cursorLine, XPODoc.getLineText( cursorLine ).substring( 0, cursorColumn ) );
			//XPODoc.insertText("\r\n", cursorLine, cursorColumn);

			// TODO: FIXME: HACK:  Need to make the above change visible in the GUI
			//clearFormatting( cursorLine );
			//var myDoc = guiDoc;
			//var addMe = myDoc.createElement('div');
			//addMe.setAttribute('id', XPODoc.getLineId( cursorLine+1 ) );
			//addMe.setAttribute('class', "line");
			//myDoc.getElementById("entireDocument").insertBefore( addMe, myDoc.getElementById( XPODoc.getLineId( cursorLine+2 ) ) );
				
			cursorLine++;
			cursorColumn = 0;
			break;
			
		case TABKEY:
			// Insert 4 spaces at current cursor position
			//  SUPER HACK:  Need to redesign functions a bit to eliminate redundancy and make it cleaner and more readable.  
			// We eventually want this to call an "insertText()" function, but for now....
			typeCharacter(" ".charCodeAt(0), XPODoc );
			typeCharacter(" ".charCodeAt(0), XPODoc );
			typeCharacter(" ".charCodeAt(0), XPODoc );
			typeCharacter(" ".charCodeAt(0), XPODoc );
			break;
			
		case SHIFTKEY:
			break;
			
		case CAPSLOCKKEY:
			break;
			
		case HIDECHATWINDOWSKEY:
			if( paramIsCtl ) { hideChatShortcut(); }
			else{ return true; }
			break;
			//For autobracketing
		case LEFTBRACKET:
			if(isFF == true)
				{
					var origCursorCol = this.getCursorColumn();
					this.setCursor(this.getCursorLine(), origCursorCol+1);
					typeCharacter("}".charCodeAt(0), XPODoc);
					this.setCursor(this.getCursorLine(), origCursorCol);
				}
			else
			{
				var curChar = XPODoc.getLineText(cursorLine).substring(cursorColumn, cursorColumn+1);
				if(curChar != '{')
				{
					typeCharacter("{".charCodeAt(0), XPODoc);
					typeCharacter("}".charCodeAt(0), XPODoc);
					this.setCursor(this.getCursorLine(), this.getCursorColumn()-1);
				}
			}
			break;
			case LEFTPAREN:
				if(isFF == true)
					{
						var origCursorCol = this.getCursorColumn();
						this.setCursor(this.getCursorLine(), origCursorCol+1);
						typeCharacter(")".charCodeAt(0), XPODoc);
						this.setCursor(this.getCursorLine(), origCursorCol);
					}
				else
				{
					var curChar = XPODoc.getLineText(cursorLine).substring(cursorColumn, cursorColumn+1);
					if(curChar != '(')
					{
						typeCharacter("(".charCodeAt(0), XPODoc);
						typeCharacter(")".charCodeAt(0), XPODoc);
						this.setCursor(this.getCursorLine(), this.getCursorColumn()-1);
					}
				}
				break;
			case FINDKEY:
				if( paramIsCtl ) { findMenuClick(); }
				else{ return true; }
				break;
			case REPLACEKEY:
				if( paramIsCtl ) { replaceMenuClick(); }
				else{ return true; }
				break;
			case GOTOKEY:
				if( paramIsCtl ) { gotoMenuClick(); }
				else{ return true; }
				break;
			case SELECTALLKEY:
				if( paramIsCtl ) { selectAllMenuClick(); }
				else{ return true; }
				break;
			case CUTKEY:
				if( paramIsCtl ) { cutIconClicked(); }
				else{ return true; }
				break;
			case COPYKEY:
				if( paramIsCtl ) { copyIconClicked(); }
				else{ return true; }
				break;
			case PASTEKEY:
				if( paramIsCtl ) { pasteIconClicked(); }
				else{ return true; }
				break;
		default:
			return true;		// Return  values are this way for the convenience of the onKeyDown event handler function
	}
	return false;	// Return  values are this way for the convenience of the onKeyDown event handler function
} // END typeSpecial(paramKEY)



/*************************************************/
/**** GUI RELATED / GUI SPECIFIC FUNCTIONS ****/

// This function displays the cursor position in the GUI
function displayCursorPos() {
	updateLineCol(cursorLine, cursorColumn);
}

// This function clears the formatting of the line specified by paramLineNumber
function clearFormatting( paramLineNum ) {
	if(guiDoc.getElementById( XPODoc.getLineId(paramLineNum) ) != null){
		//guiDoc.getElementById( XPODoc.getLineId(paramLineNum) ).innerHTML = XPODoc.getLineText(paramLineNum);

		//RT - NOT SURE WHAT THIS DOES....
		//Parses the contents of each line for syntax hightlighting.
//		guiDoc.getElementById( XPODoc.getLineId(paramLineNum) ).innerHTML = indexLineText(replaceHTMLEntities(XPODoc.getLineText(paramLineNum)));
		guiDoc.getElementById( XPODoc.getLineId(paramLineNum) ).innerHTML = indexLineText(XPODoc.getLineText(paramLineNum));
	}
}

// This function clears the old cursor and moves to the line specified by paramLineNumber
function gotoLine( paramLineNum ) {
	//clearFormatting(cursorLine);
	cursorLine = paramLineNum;
	cursorColumn = 0;
	adjustScroll();
}

// This function clears the old cursor and moves to the line specified by paramLineNumber
function gotoPosition( paramLineNum, paramColNum ) {
	//clearFormatting(cursorLine);
	cursorLine = paramLineNum;
	cursorColumn = paramColNum;
	adjustScroll();
}

// This function takes each line of input and applies formatting based on keywords
function indexLineText(inputText)
{
// This function or a subsequent one is slow as hell.  bypass that for now by just returning the inputtext
return inputText;
	var newLine = "";
//	var testArr = new Array("public", "static", "void");
	var words = inputText.split(" ");
	

		for(var counter = 0; counter < words.size(); counter++)
		{	
			var curWord = words[counter];
	
			if(tokenSearch(curWord))
			{
				var markedWord = writeSpans(curWord, "");
				newLine += markedWord;
				newLine += writeSpans("", "space");
			}
			else
			{
				var unmarkedWord = writeSpans(curWord, "none");
				newLine += unmarkedWord;
				newLine += writeSpans("", "space");
			}
	//	}
	}
	return newLine;
}

// This function highlights and locks lines given by the 'newLineLocks' array it receives
function lockLines( newLineLocks ) {
	// Clear the old line locks
	for( var i=0; i < lockedLines.length; i++ )
	{
		clearFormatting( lockedLines[i].lineID );
	}
	// Add the new line locks
	for( var j=0; j < newLineLocks.length; j++ )
	{		
		guiDoc.getElementById( XPODoc.getLineId(newLineLocks[j].lineID) ).innerHTML = "<span class='lock' onMouseOver=\"makeNewLockPopup(event,'lock"+j+"','"+newLineLocks[j].userName+"')\" onMouseOut=\"closeLockPopup('lock"+j+"')\">" + XPODoc.getLineText(newLineLocks[j].lineID) + "</span>";		
	}
	lockedLines = newLineLocks;
}

// This function renders the cursor in the document. 
function renderCursor() 
{
	             // Slice 'n dice the line to isolate the cursor
	                var tempCurrentLine = new Array();

	                tempCurrentLine.push(XPODoc.getLineText(cursorLine).substring(0,cursorColumn));
	                tempCurrentLine.push(XPODoc.getLineText(cursorLine).substr(cursorColumn, 1));
	                tempCurrentLine.push(XPODoc.getLineText(cursorLine).substring(cursorColumn+1));

					//If syntax highlighting is enabled
					if(checkSyntaxHighlighting())
					{
						//Parse the line text for any tokens and return the parsed html
		                var formatted = indexLineText(tempCurrentLine[0] + tempCurrentLine[1] + tempCurrentLine[2]);
										
						//An attempt to get all of the span tags in the current line
						var allSpans = new RegExp("<span\\b[^>]*>(.*?)</span> ?", "g");							
						
						var spansArray = formatted.match(allSpans, "gi");
							
							//If the line is empty, then just render the cursor where it is
							if(spansArray == null)
							{
								tempCurrentLine[1] = "<span id='cursor'>" + tempCurrentLine[1] + "</span>";  
								guiDoc.getElementById( XPODoc.getLineId(cursorLine) ).innerHTML = tempCurrentLine.join("")
								return;
							}
							else
							{
								//Grab the cursorColumn-th span in the array, which is where the 
								//cursor should be
								var cursorOn = "";
								cursorOn = spansArray[cursorColumn];
				
								var cursorRegExp = new RegExp("<span\\b[^>]*>");
								var temp = cursorOn.replace(cursorRegExp, "<span id='cursor'>");

								spansArray[cursorColumn] = temp;
								
								delete cursorOn;
								delete cursorRegExp;
								delete temp;
								
								var newString = "";
								for(var counter = 0; counter < spansArray.size(); counter++)
								{
									newString +=spansArray[counter];
								}
							}
						  	// display new formatting
		                	try 
							{
		                        guiDoc.getElementById( XPODoc.getLineId(cursorLine) ).innerHTML = newString;
			                }
			                catch (e) { alert("line not found!!!!!!!!11111"); }
					}
					else
					{
						//Check if the cursor selection has anything. 
						if(tempCurrentLine[1] == ""){tempCurrentLine[1] = "<span id='cursor'> </span>";}
						else
						{
                 			tempCurrentLine[1] = "<span id='cursor'>" + tempCurrentLine[1] + "</span>";
						}
						
                		try 
						{
                   			guiDoc.getElementById( XPODoc.getLineId(cursorLine) ).innerHTML = tempCurrentLine.join("");
                		}
	            		catch (e) { alert("line not found!!!!!!!!!!11111"); }
					}
			
	       // Update the GUI with the correct line and col
	       displayCursorPos();
	
}

/* Replace some things like tabs, spaces, < and > */
//function replaceHTMLEntities( paramText ) {
//	paramText = paramText.replace(/&/g, "&amp;"); // Leave this one first.
//	paramText = paramText.replace(/>/g, "&gt;");
//	paramText = paramText.replace(/</g, "&lt;");
///	paramText = paramText.replace(/ /g, "&nbsp;");	
//	paramText = paramText.replace(/\//g, "&#47;");
//	paramText = paramText.replace(/\\/g, "&#92;");
//	paramText = paramText.replace(/\t/g,"&nbsp;&nbsp;&nbsp;&nbsp;");
//	return paramText;
//}

/* This function (re-)renders the entire document */
function refreshDocument() {
	var myDoc = guiDoc.getElementById("entireDocument");
	while ( myDoc.firstChild ) {
		myDoc.removeChild( myDoc.firstChild );
	}
	
	for(var l=0; l < XPODoc.document.length; l++ ){
		var newLine = guiDoc.createElement('div');
		newLine.setAttribute('id', XPODoc.getLineId(l) );
		newLine.setAttribute('class', "line");		// RELATED TO FIX OF ISSUE #1 >> See DEVLOG.TXT is
		myDoc.appendChild( newLine );				
		if ( l == cursorLine ) {/*renderCursor();*/;}
		else ;//clearFormatting( l );
	}
}


// This function will perform auto-scrolling of the iFrame to keep the cursor in view at all times
function adjustScroll() {
	// TODO: COMMENT THIS FUNCTION
	var frameWidth;
	var frameHeight;
	if(isIE == true){
		frameWidth = guiDoc.body.clientWidth;
		frameHeight = guiDoc.body.clientHeight;
	}
	else{
		frameWidth = myIFrame.contentWindow.innerWidth;
		frameHeight = myIFrame.contentWindow.innerHeight;
	}

	//var frameWidth = myIFrame.contentWindow.innerWidth;
	//var frameHeight = myIFrame.contentWindow.innerHeight;
	var cursorDocOffsetX = (cursorColumn*FONT_WIDTH) + PADDING_LEFT;
	var cursorDocOffsetY = (cursorLine*FONT_HEIGHT) + PADDING_TOP;
	var visibleEdgeX = getScrollOffsetX()+frameWidth-FONT_WIDTH;
	var visibleEdgeY = getScrollOffsetY()+frameHeight-FONT_HEIGHT;
	var scrollAmountX=0;
	var scrollAmountY=0;
	
	if (cursorDocOffsetX>visibleEdgeX) scrollAmountX=cursorDocOffsetX-visibleEdgeX+100;
	else if (cursorDocOffsetX<getScrollOffsetX()) scrollAmountX=cursorDocOffsetX-getScrollOffsetX()-100;
	if (cursorDocOffsetY>visibleEdgeY) scrollAmountY=cursorDocOffsetY-visibleEdgeY+100;
	else if (cursorDocOffsetY<getScrollOffsetY()) scrollAmountY=cursorDocOffsetY-getScrollOffsetY()-100;
	
	if(isIE == true) myIFrame.scrollBy(scrollAmountX, scrollAmountY);
	else myIFrame.contentWindow.scrollBy(scrollAmountX, scrollAmountY);
}


/**********************************************/
/****** DOCUMENT SYNCHRONIZATION *****/

// This will be an 'update' that we will send to the server
function updateObject(paramAction, paramText, paramLineNum){
	this.action = paramAction;
	this.text = paramText;
	this.lineNum = paramLineNum;
	this.documentID = XPODoc.documentID;
}

// we might want to move this into the document
var pendingServerUpdates = new Array();

// paramAction: i (insert), u (update), d (delete)
// paramText: the new text for the affected line
// paramLineNum: the line where the action will take place
function updateDocument( paramAction, paramText, paramLineNum ) {
	// Fix the line locks
	if(paramAction == "i" || paramAction == "d"){
		for( var i=0; i < lockedLines.length; i++ )
		{			
			if(paramAction == "i" && lockedLines[i].lineID > paramLineNum){
				lockedLines[i].lineID = parseInt(lockedLines[i].lineID) + 1;
			}
			else if(paramAction == "d" && lockedLines[i].lineID > paramLineNum){
				lockedLines[i].lineID = parseInt(lockedLines[i].lineID) - 1;
			}
		}
	}
	
	// If we have multiple updates to the same line in a row, just use the latest one.
	var arrayLength = pendingServerUpdates.length;
	if(arrayLength > 0){
		var lastUpdateObj = pendingServerUpdates[ arrayLength-1 ];
		if(lastUpdateObj.action == "u" && paramAction == "u" && lastUpdateObj.lineNum == paramLineNum){
			pendingServerUpdates[ arrayLength-1 ] = new updateObject(paramAction, paramText, paramLineNum);
			return;
		}
	}
	pendingServerUpdates.push( new updateObject(paramAction, paramText, paramLineNum) );
}

setTimeout('sendDocumentUpdates()',5000);

function sendDocumentUpdates(){

	if(pendingServerUpdates.length > 0){
		new Ajax.Request('./handlers/documentUpdate.php?', {
			method:'post',
			postBody: 'updateData='+pendingServerUpdates.toJSON(),
			onSuccess: function(transport) {
				if(transport.responseText != ""){
					//alert(transport.responseText);
				}
			}		
		});
		
		// Clear out the array so it doesn't send again.  We should probably also keep a record somewhere of them for awhile
		pendingServerUpdates  = new Array();
	}
	
	// Every 1 second, see if there is anything to send again
	setTimeout('sendDocumentUpdates()', 1000);
}

function updateLineLock( line ) {
	new Ajax.Request('./documents/lineLock/updateLineLock.php?curLine='+line+'&docID='+XPODoc.documentID, {
		method:'get'		
	});
}



/*************************************************/
/******* INITIALIZATION / LOAD FUNCTIONS *****/

function init() {
	/* Get handle on main document object */
	mainDoc = document;	
	
	/* BROWSER DETECTION */
	var ua = navigator.userAgent.toLowerCase();	
	isFF = (ua.indexOf("firefox") != -1);
	isIE = (ua.indexOf("msie") != -1);
	isChrome = (ua.indexOf("chrome") != -1);
	isSafari = (ua.indexOf("safari") != -1) && (ua.indexOf("chrome") == -1);
	
	/* Get browser-dependent handle on the iFrame and the iFrame's content document */
	if(isIE == false) myIFrame = document.getElementById("myI");
	else myIFrame = frames["myI"];
	
	/* Get handle on iFrame's content document */
	if(isIE == true) guiDoc = myIFrame.document;
	else guiDoc = myIFrame.contentWindow.document;
		
	/* Initialize our text document data structure */
	XPODoc = new TextDocument( guiDoc );
}

/* This function is responsible for (re-)initializing the text data structure, given a document ID, text, and setting the access mode */
function loadNewDoc(docID, docText, accessMode) {
	/* Ensure that the text data structure is clean  */
	// NOTE:  Couldn't we instead, simply do:  XPODoc = new TextDocument();  ????  Would that be less efficient?
	XPODoc.blankDocument();
	XPODoc.documentID = docID;
	
	/* Populate the XPODoc data structure */
	XPODoc.insertText(docText);
	
	/* Set the access mode.  If not readonly, it shall be assume read-write */
	readOnly = (accessMode == "r");
	
	/* Add event listeners, but only if the mode is read-write (NOT readOnly) */
	if(readOnly == false){
		if(isIE == true || isChrome == true || isSafari == true){
			guiDoc.onclick = onClickFunction;
			guiDoc.onkeypress = onKeyPressFunction;
			guiDoc.onkeydown = onKeyDownFunction;
		}
		else{
			guiDoc.addEventListener("click", onClickFunction, true);
			guiDoc.addEventListener("keydown", onKeyDownFunction, true);
			guiDoc.addEventListener("keypress", onKeyPressFunction, true);
		}
	}
	else{ // Remove event listeners because we are in readOnly mode
		if(isIE == true || isChrome == true || isSafari == true){
			guiDoc.onclick = null;
			guiDoc.onkeydown = null;
			guiDoc.onkeypress = null;
		}
		else{
			guiDoc.removeEventListener("click", onClickFunction, true);
			guiDoc.removeEventListener("keydown", onKeyDownFunction, true);
			guiDoc.removeEventListener("keypress", onKeyPressFunction, true);
		}
	}
	
	/* Ensure that the text 'window' has the focus, thus allowing immediate editing (if eventListeners are active, of course) */
	if(isIE == true) myIFrame.focus();
	else myIFrame.contentWindow.focus();
	
	/* Initialize the cursor to the starting position */
	setCursor(0,0);
	
	/* Render the entire document */
	//refreshDocument();
	//renderCursor();
	XPODoc.renderEntireDocument();
}



/***************************************************/
/*********** EVENT HANDLER FUNCTIONS ***********/

/* This function is the handler for the onclick event. */
onClickFunction = function( paramEvent ){
	XPODoc.setLineUpdated( cursorLine );
	var oldCursorLine = cursorLine;
	//clearFormatting(cursorLine);
	captureMousePos(paramEvent);
	deriveCursorForDocument(mouseX,mouseY,XPODoc);
	if(oldCursorLine != cursorLine) {
		XPODoc.setLineUpdated( cursorLine );
		updateLineLock(cursorLine);
	}
	XPODoc.renderUpdates( cursorLine, cursorColumn );
}

/* This function is the handler of the keydown event.  Mainly, this function will execute the typeSpecial function */
onKeyDownFunction = function( paramEvent ) {
	XPODoc.setLineUpdated( cursorLine );
	var oldCursorLine = cursorLine;
	//clearFormatting(cursorLine);
	
	// Determine the keyCode of the pressed key (browser-dependent implementation)
	var key;
	var isShift;
	var isAlt;
	var isCtl;
	if(isIE == true){ 
		key = myIFrame.window.event.keyCode;
		isShift = myIFrame.window.event.shiftKey;
		isAlt = myIFrame.window.event.altKey;
		isCtl = myIFrame.window.event.ctrlKey;
	}
	else{ 
		key = paramEvent.keyCode;
		isShift = paramEvent.shiftKey;
		isAlt = paramEvent.altKey;
		isCtl = paramEvent.ctrlKey;
	}

	// if typeSpecial actually did something, it returns false...
	var returnValue = typeSpecial( key, isAlt, isCtl, isShift );
	//var returnValue = typeSpecial( key );

	XPODoc.setLineUpdated( cursorLine );
	//adjustScroll();
	if(oldCursorLine != cursorLine) {
		XPODoc.setLineUpdated( cursorLine );
		updateLineLock(cursorLine);
	}
	XPODoc.renderUpdates( cursorLine, cursorColumn );
	return returnValue;	//  ... and if typeSpecial returns false, we don't want the event to bubble, so pass this return value along
}


/* This function is the handler for the keypress event.  Mainly, this function will execute the typeCharacter function, if applicable */
onKeyPressFunction = function( paramEvent ){
	var oldCursorLine = cursorLine;
	//clearFormatting(cursorLine);
	
	// Determine the ASCII code of the to-be-typed character (browser-dependent implementation)
	var key;
	if(isFF == true) key = paramEvent.charCode;
	else if(isIE == true) key = myIFrame.window.event.keyCode;
	else if(isChrome == true || isSafari == true) key = paramEvent.keyCode;
	else alert('an unknown browser... editing may not work.');

	// If a valid character (nonzero), then type it
	if ( key != 0 ) typeCharacter( key );
	
	adjustScroll();
	
	if(oldCursorLine != cursorLine) {
		updateLineLock(cursorLine);
	}
	XPODoc.renderUpdates( cursorLine, cursorColumn );
}

/* This function is the handler of the mousedown event */
onMouseDownFunction = function( paramEvent ) {

}
</script>
<iframe id="myI" name="myI" src="./editor/editableContent.html" style="width:100%;height:100%;"></iframe>