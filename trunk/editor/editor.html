<script type="text/javascript" charset="utf-8" src="tokensearch.js"></script>
<script type="text/javascript" charset="utf-8" src="writeSpans.js"></script>
<script type="text/javascript" charset="utf-8" src="editor/TextDocumentClass.js"></script>
<script type="text/javascript" charset="utf-8" src="editor/userInputLogic.js"></script>
<script type="text/javascript" src="jWords.js"></script>
<script type="text/javascript" charset="utf-8" src = "editor/toggleSH.js"></script>
<script type="text/javascript">

/**********************************************/
/********** DECLARE GLOBAL VARIABLES **********/

// Browser(HTML) document related globals
var myIFrame;
var mainDoc;

// Browser specific
var isFF;
var isIE;
var isChrome;
var isSafari;

// CSS related constants
var FONT_WIDTH = 8;
var FONT_HEIGHT = 17;
var PADDING_TOP = 8;
var PADDING_LEFT = 8;

// Text document container
var XPODoc;

// Text-editing related global flags (to be treated as BOOLEAN variables)
var isShiftDown;
var isCtlDown;
var isAltDown;

// Other stuff
var readOnly = true;
var syntaxHighlightOn = true;
var lockedLines = new Array();

// HTML-DOM handle for document pane
var guiDoc;

/*********** END OF GLOBAL VARIABLES ********/
/**********************************************/

function getDoc(){
	if(isIE == true){
		return myIFrame.document;
	}
	else{
		return myIFrame.contentWindow.document;
	}
}


// This function does a raw capture of mouse position, given an event
function captureMousePos(e) {
	if(isIE == true){
		//this is cory's attempt... its not perfect, but it shows how you can do it
		e = myIFrame.window.event;
		mouseX = e.clientX + guiDoc.body.scrollLeft - 3;
        mouseY = e.clientY + guiDoc.body.scrollTop - 3;
	}
	else{
		mouseX = e.pageX;
		mouseY = e.pageY;
	}
}

/* These two functions return the numeric value for the scroll offset of the iFrame */
function getScrollOffsetX() {
	if(isIE == true) return guiDoc.body.scrollLeft;
	else return myIFrame.contentWindow.pageXOffset;
}
function getScrollOffsetY() {
	if(isIE == true) return guiDoc.body.scrollTop;
	else return myIFrame.contentWindow.pageYOffset;
}



/**************************************************/
/******** USER INPUT RELATED FUNCTIONS ********/

// This function inserts a bookmark into the document and displays it
function insertBookmark( paramBMtext ) {
	if( XPODoc.getLineText( cursorLine ).trim() == "" ){
		XPODoc.setLineText( cursorLine, paramBMtext );
		clearFormatting( cursorLine );
		renderCursor();
	}
	else{
		XPODoc.insertLine( cursorLine+1, XPODoc.getLineText( cursorLine ) );
		XPODoc.setLineText( cursorLine, paramBMtext );

		// TODO: FIXME: HACK:  Need to make the above change visible in the GUI
		// The following lines are very similar to the code in ENTER
		clearFormatting( cursorLine );
		var myDoc = guiDoc;
		var addMe = myDoc.createElement('div');
		addMe.setAttribute('id', XPODoc.getLineId( cursorLine+1 ) );
		addMe.setAttribute('class', "line");
		myDoc.getElementById("entireDocument").insertBefore( addMe, myDoc.getElementById( XPODoc.getLineId( cursorLine+2 ) ) );
		
		cursorLine++;
		cursorColumn = 0;
		
		renderCursor();
	}
}

/* This function provides functionality to so-called "special keys".  Basically, any non-character related keyboard input. (kindof) */
function typeSpecial(paramKEYCODE, paramIsAlt, paramIsCtl, paramIsShift) {
	
	switch ( paramKEYCODE ) {
	
		case LEFTARROWKEY: 
			/* If we are holding shift, moving the cursor actually selects text, so we need to ensure we are in select mode */
			if ( paramIsShift ) if ( !isSelectMode ) setSelectMode();
			
			// If we are at the first char of the first line do nothing
			// If we are at the first char of any other line, wrap to the last char of the previous line
			// Otherwise, simply move left
			if ( cursorColumn == 0 && cursorLine == 0 ) break;
			if ( cursorColumn == 0 ) {
				cursorLine--;
				cursorColumn = XPODoc.getLineLength(cursorLine)-1;
			}
			else cursorColumn--;	
			break;
			
		case RIGHTARROWKEY:
			/* If we are holding shift, moving the cursor actually selects text, so we need to ensure we are in select mode */
			if ( paramIsShift ) if ( !isSelectMode ) setSelectMode();
			
			// If we are at the last char of the last line, do nothing
			// If we are at the last char of any other line, wrap to the first char of the next line
			// Otherwise, simply move right
			if ( cursorColumn == XPODoc.getLineLength(cursorLine) && cursorLine == XPODoc.getDocumentLength()-1 ) break;
			if ( cursorColumn == XPODoc.getLineLength(cursorLine) ) {
				cursorLine++;
				cursorColumn = 0;
			}
			else cursorColumn++;
			break;
			
		case UPARROWKEY:
			/* If we are holding shift, moving the cursor actually selects text, so we need to ensure we are in select mode */
			if ( paramIsShift ) if ( !isSelectMode ) setSelectMode();
			
			// If we are on the first line, move to first char of line.
			// Otherwise, move up. If we end up out of range of the line, move to the last char of the line
			if ( cursorLine == 0 ) cursorColumn = 0;
			else if ( cursorColumn > XPODoc.getLineLength(--cursorLine) ) cursorColumn = XPODoc.getLineLength(cursorLine);
			break;
			
		case DOWNARROWKEY:
			/* If we are holding shift, moving the cursor actually selects text, so we need to ensure we are in select mode */
			if ( paramIsShift ) if ( !isSelectMode ) setSelectMode();
			
			// If we are on the last line, move to last char of line.
			// Otherwise, move down. If we end up out of range of the line, move to the last char of the line
			if ( cursorLine == XPODoc.getDocumentLength()-1 ) cursorColumn = XPODoc.getLineLength(cursorLine);
			else if ( cursorColumn > XPODoc.getLineLength(++cursorLine) ) cursorColumn = XPODoc.getLineLength(cursorLine);
			break;
			
		case ENDKEY:
			/* If we are holding shift, moving the cursor actually selects text, so we need to ensure we are in select mode */
			if ( paramIsShift ) if ( !isSelectMode ) setSelectMode();
			
			// Move to the last char of the current line
			cursorColumn = XPODoc.getLineLength(cursorLine);
			break;
			
		case HOMEKEY:
			/* If we are holding shift, moving the cursor actually selects text, so we need to ensure we are in select mode */
			if ( paramIsShift ) if ( !isSelectMode ) setSelectMode();
			
			// Move to the first char of the current line
			cursorColumn = 0;
			break;
			
		case PAGEUPKEY:
			/* If we are holding shift, moving the cursor actually selects text, so we need to ensure we are in select mode */
			if ( paramIsShift ) if ( !isSelectMode ) setSelectMode();
			
			// Move the cursor up a number of time relative to the current editing window's height			
			if(isIE == true){
				cursorLine -= Math.floor(guiDoc.body.clientHeight / FONT_HEIGHT);
			}
			else{
				cursorLine -= Math.floor(myIFrame.contentWindow.innerHeight / FONT_HEIGHT);
			}
			// Do out-of-bounds checks
			if ( cursorLine < 0 ) {
				cursorLine = 0;
				cursorColumn = 0;
			} else if ( cursorColumn >= XPODoc.getLineLength( cursorLine ) ) cursorColumn = XPODoc.getLineLength(cursorLine);
			if(isIE == true){
				myIFrame.scrollBy(0,-guiDoc.body.clientHeight+PADDING_TOP);
			}
			else{
				myIFrame.contentWindow.scrollBy(0,-myIFrame.contentWindow.innerHeight+PADDING_TOP);
			}
			break;
					
		case PAGEDOWNKEY:
			/* If we are holding shift, moving the cursor actually selects text, so we need to ensure we are in select mode */
			if ( paramIsShift ) if ( !isSelectMode ) setSelectMode();
			
			// Move the cursor down a number of times relative to the current editing window's height
			if(isIE == true){
				cursorLine += Math.floor(guiDoc.body.clientHeight / FONT_HEIGHT);
			}
			else{
				cursorLine += Math.floor(myIFrame.contentWindow.innerHeight / FONT_HEIGHT);
			}
			// Do out-of-bounds checks
			if ( cursorLine > XPODoc.getDocumentLength()-1 ) {
				cursorLine = XPODoc.getDocumentLength()-1;
				cursorColumn = XPODoc.getLineLength( cursorLine )-1;
			} else if ( cursorColumn >= XPODoc.getLineLength( cursorLine ) ) cursorColumn = XPODoc.getLineLength(cursorLine);
			if(isIE == true){
				myIFrame.scrollBy(0,guiDoc.body.clientHeight-PADDING_TOP);
			}
			else{
				myIFrame.contentWindow.scrollBy(0,myIFrame.contentWindow.innerHeight-PADDING_TOP);
			}
			break;
			
		case BACKSPACEKEY:
			// If we are on the first char of the first line, do nothing.
			// If we are on the first char of any other line, backspace removes the "newline character"
			// -- which doesn't exist in our implementation.  We simulate this removal by merging lines.
			// Otherwise, we simply remove the previous char in the current line
			if ( cursorLine == 0 && cursorColumn == 0 ) break;
			if ( cursorColumn == 0 ) {
				// Merge the two lines, and remove the original line
				cursorColumn = XPODoc.getLineLength( cursorLine-1 );	// Place cursor at end of prior line
				// Perform text merge into prior line
				XPODoc.setLineText( cursorLine-1, XPODoc.getLineText( cursorLine-1 ) + XPODoc.getLineText( cursorLine ) );
				
				// FIXME: HACK:  BAD FORM!  The following lines promote tight coupling between GUI and backend!  ARRRGGGGHHHHH! 
				var removeMe = guiDoc.getElementById(XPODoc.getLineId( cursorLine ));
				removeMe.parentNode.removeChild(removeMe);
				
				// Remove the line from our data structure
				XPODoc.removeLine( cursorLine );
				// Decrement cursorLine
				cursorLine--;
			} else {
				// "Remove" the character prior to cursorColumn, and decrement cursorColumn
				var tempText = XPODoc.getLineText( cursorLine );
				XPODoc.setLineText( cursorLine, tempText.substring(0,cursorColumn-1) + tempText.substring(cursorColumn--) );
			}
			break;
			
		case DELETEKEY:
			// If we are at the last char of the last line, do nothing
			// If we are at the last char of any other line, we remove the 'newline character', thus merging the current line with the next line
			// Otherwise, we simply remove the char at the cursor position
			if ( cursorColumn == XPODoc.getLineLength( XPODoc.getDocumentLength()-1 )-1 && cursorLine == XPODoc.getDocumentLength()-1 ) break;
			if ( cursorColumn == XPODoc.getLineLength( cursorLine )-1 ) {
				// Merge the next line into the current line
				XPODoc.setLineText( cursorLine, XPODoc.getLineText(cursorLine) + XPODoc.getLineText(cursorLine+1) );
				
				// FIXME: HACK:  BAD FORM!  The following lines promote tight coupling between GUI and backend!  ARRRGGGGHHHHH! 
				var removeMe = guiDoc.getElementById(XPODoc.getLineId( cursorLine+1 ));
				removeMe.parentNode.removeChild(removeMe);
				
				// Remove the line in question from our data structure
				XPODoc.removeLine( cursorLine+1 );
			} else {
				// "Remove" the character at the cursorColumn position
				var tempText = XPODoc.getLineText( cursorLine );
				XPODoc.setLineText( cursorLine, tempText.substring(0,cursorColumn) + tempText.substring(cursorColumn+1) );
			}
			break;
			
		case ENTERKEY:
			// When we press the enter key, we need to insert a new line into the document
			// We need to insert a new line following the current line, which contains the current line's text starting from the cursor
			XPODoc.insertLine( cursorLine+1, XPODoc.getLineText( cursorLine ).substring( cursorColumn ) );
			XPODoc.setLineText( cursorLine, XPODoc.getLineText( cursorLine ).substring( 0, cursorColumn ) );
			//XPODoc.insertText("\r\n", cursorLine, cursorColumn);

			// TODO: FIXME: HACK:  Need to make the above change visible in the GUI
			clearFormatting( cursorLine );
			var myDoc = guiDoc;
			var addMe = myDoc.createElement('div');
			addMe.setAttribute('id', XPODoc.getLineId( cursorLine+1 ) );
			addMe.setAttribute('class', "line");
			myDoc.getElementById("entireDocument").insertBefore( addMe, myDoc.getElementById( XPODoc.getLineId( cursorLine+2 ) ) );
				
			cursorLine++;
			cursorColumn = 0;
			break;
			
		case TABKEY:
			// Insert 4 spaces at current cursor position
			//  SUPER HACK:  Need to redesign functions a bit to eliminate redundancy and make it cleaner and more readable.  
			// We eventually want this to call an "insertText()" function, but for now....
			typeCharacter(" ".charCodeAt(0), XPODoc );
			typeCharacter(" ".charCodeAt(0), XPODoc );
			typeCharacter(" ".charCodeAt(0), XPODoc );
			typeCharacter(" ".charCodeAt(0), XPODoc );
			break;
			
		case SHIFTKEY:
			break;
			
		case CAPSLOCKKEY:
			break;
			
		default:
			return true;		// Return  values are this way for the convenience of the onKeyDown event handler function
	}
	return false;	// Return  values are this way for the convenience of the onKeyDown event handler function
} // END typeSpecial(paramKEY)



/*************************************************/
/**** GUI RELATED / GUI SPECIFIC FUNCTIONS ****/

// This function displays the cursor position in the GUI
function displayCursorPos() {
	updateLineCol(cursorLine, cursorColumn);
}

// This function clears the formatting of the line specified by paramLineNumber
function clearFormatting( paramLineNum ) {
	if(guiDoc.getElementById( XPODoc.getLineId(paramLineNum) ) != null){
		//guiDoc.getElementById( XPODoc.getLineId(paramLineNum) ).innerHTML = XPODoc.getLineText(paramLineNum);

		//RT - NOT SURE WHAT THIS DOES....
		//Parses the contents of each line for syntax hightlighting.
//		guiDoc.getElementById( XPODoc.getLineId(paramLineNum) ).innerHTML = indexLineText(replaceHTMLEntities(XPODoc.getLineText(paramLineNum)));
		guiDoc.getElementById( XPODoc.getLineId(paramLineNum) ).innerHTML = indexLineText(XPODoc.getLineText(paramLineNum));
	}
}

// This function clears the old cursor and moves to the line specified by paramLineNumber
function gotoLine( paramLineNum ) {
	clearFormatting(cursorLine);
	cursorLine = paramLineNum;
	cursorColumn = 0;
	renderCursor();
	adjustScroll();
}

// This function clears the old cursor and moves to the line specified by paramLineNumber
function gotoPosition( paramLineNum, paramColNum ) {
	clearFormatting(cursorLine);
	cursorLine = paramLineNum;
	cursorColumn = paramColNum;
	renderCursor();
	adjustScroll();
}

// This function takes each line of input and applies formatting based on keywords
function indexLineText(inputText)
{
	var newLine = "";
//	var testArr = new Array("public", "static", "void");
	var words = inputText.split(" ");
	

		for(var counter = 0; counter < words.size(); counter++)
		{	
			var curWord = words[counter];
	
			if(tokenSearch(curWord))
			{
				var markedWord = writeSpans(curWord, "");
				newLine += markedWord;
				newLine += writeSpans("", "space");
			}
			else
			{
				var unmarkedWord = writeSpans(curWord, "none");
				newLine += unmarkedWord;
				newLine += writeSpans("", "space");
			}
	//	}
	}
	//alert("I'm about to return " + newLine);
	return newLine;
}

// This function highlights and locks lines given by the 'newLineLocks' array it receives
function lockLines( newLineLocks ) {
	// Clear the old line locks
	for( var i=0; i < lockedLines.length; i++ )
	{
		clearFormatting( lockedLines[i].lineID );
	}
	// Add the new line locks
	for( var j=0; j < newLineLocks.length; j++ )
	{		
		guiDoc.getElementById( XPODoc.getLineId(newLineLocks[j].lineID) ).innerHTML = "<span class='lock' onMouseOver=\"makeNewLockPopup(event,'lock"+j+"','"+newLineLocks[j].userName+"')\" onMouseOut=\"closeLockPopup('lock"+j+"')\">" + XPODoc.getLineText(newLineLocks[j].lineID) + "</span>";		
	}
	lockedLines = newLineLocks;
}

// This function renders the cursor in the document. 
function renderCursor() 
{
	             // Slice 'n dice the line to isolate the cursor
	                var tempCurrentLine = new Array();

	                tempCurrentLine.push(XPODoc.getLineText(cursorLine).substring(0,cursorColumn));
	                tempCurrentLine.push(XPODoc.getLineText(cursorLine).substr(cursorColumn, 1));
	                tempCurrentLine.push(XPODoc.getLineText(cursorLine).substring(cursorColumn+1));

					//If syntax highlighting is enabled
					if(checkSyntaxHighlighting())
					{
						//Parse the line text for any tokens and return the parsed html
		                var formatted = indexLineText(tempCurrentLine[0] + tempCurrentLine[1] + tempCurrentLine[2]);
										
						//An attempt to get all of the span tags in the current line
						var allSpans = new RegExp("<span\\b[^>]*>(.*?)</span> ?", "g");							
						
						var spansArray = formatted.match(allSpans, "gi");
							
							//If the line is empty, then just render the cursor where it is
							if(spansArray == null)
							{
								tempCurrentLine[1] = "<span id='cursor'>" + tempCurrentLine[1] + "</span>";  
								getDoc().getElementById( XPODoc.getLineId(cursorLine) ).innerHTML = tempCurrentLine.join("")
								return;
							}
							else
							{
								//Grab the cursorColumn-th span in the array, which is where the 
								//cursor should be
								var cursorOn = "";
								cursorOn = spansArray[cursorColumn];
				
								var cursorRegExp = new RegExp("<span\\b[^>]*>");
								var temp = cursorOn.replace(cursorRegExp, "<span id='cursor'>");

								spansArray[cursorColumn] = temp;
								
								delete cursorOn;
								delete cursorRegExp;
								delete temp;
								
								var newString = "";
								for(var counter = 0; counter < spansArray.size(); counter++)
								{
									newString +=spansArray[counter];
								}
							}
						  	// display new formatting
		                	try 
							{
		                        getDoc().getElementById( XPODoc.getLineId(cursorLine) ).innerHTML = newString;
			                }
			                catch (e) { alert("line not found!"); }
					}
					else
					{
						//Check if the cursor selection has anything. 
						if(tempCurrentLine[1] == ""){tempCurrentLine[1] = "<span id='cursor'> </span>";}
						else
						{
                 			tempCurrentLine[1] = "<span id='cursor'>" + tempCurrentLine[1] + "</span>";
						}
						
                		try 
						{
                   			getDoc().getElementById( XPODoc.getLineId(cursorLine) ).innerHTML = tempCurrentLine.join("");
                		}
	            		catch (e) { alert("line not found!"); }
					}
			
	       // Update the GUI with the correct line and col
	       displayCursorPos();
	
}

/* Replace some things like tabs, spaces, < and > */
function replaceHTMLEntities( paramText ) {
	paramText = paramText.replace(/&/g, "&amp;"); // Leave this one first.
	paramText = paramText.replace(/>/g, "&gt;");
	paramText = paramText.replace(/</g, "&lt;");
	paramText = paramText.replace(/ /g, "&nbsp;");	
	paramText = paramText.replace(/\//g, "&#47;");
	paramText = paramText.replace(/\\/g, "&#92;");
	paramText = paramText.replace(/\t/g,"&nbsp;&nbsp;&nbsp;&nbsp;");
	return paramText;
}

/* This function (re-)renders the entire document */
function refreshDocument() {
	var myDoc = guiDoc.getElementById("entireDocument");
	while ( myDoc.firstChild ) {
		myDoc.removeChild( myDoc.firstChild );
	}
	
	for(var l=0; l < XPODoc.document.length; l++ ){
		var newLine = guiDoc.createElement('div');
		newLine.setAttribute('id', XPODoc.getLineId(l) );
		newLine.setAttribute('class', "line");		// RELATED TO FIX OF ISSUE #1 >> See DEVLOG.TXT is
		myDoc.appendChild( newLine );				
		if ( l == cursorLine ) {renderCursor();}
		else clearFormatting( l );
	}
}


// This function will perform auto-scrolling of the iFrame to keep the cursor in view at all times
function adjustScroll() {
	// TODO: COMMENT THIS FUNCTION
	var frameWidth;
	var frameHeight;
	if(isIE == true){
		frameWidth = guiDoc.body.clientWidth;
		frameHeight = guiDoc.body.clientHeight;
	}
	else{
		frameWidth = myIFrame.contentWindow.innerWidth;
		frameHeight = myIFrame.contentWindow.innerHeight;
	}

	//var frameWidth = myIFrame.contentWindow.innerWidth;
	//var frameHeight = myIFrame.contentWindow.innerHeight;
	var cursorDocOffsetX = (cursorColumn*FONT_WIDTH) + PADDING_LEFT;
	var cursorDocOffsetY = (cursorLine*FONT_HEIGHT) + PADDING_TOP;
	var visibleEdgeX = getScrollOffsetX()+frameWidth-FONT_WIDTH;
	var visibleEdgeY = getScrollOffsetY()+frameHeight-FONT_HEIGHT;
	var scrollAmountX=0;
	var scrollAmountY=0;
	
	if (cursorDocOffsetX>visibleEdgeX) scrollAmountX=cursorDocOffsetX-visibleEdgeX+100;
	else if (cursorDocOffsetX<getScrollOffsetX()) scrollAmountX=cursorDocOffsetX-getScrollOffsetX()-100;
	if (cursorDocOffsetY>visibleEdgeY) scrollAmountY=cursorDocOffsetY-visibleEdgeY+100;
	else if (cursorDocOffsetY<getScrollOffsetY()) scrollAmountY=cursorDocOffsetY-getScrollOffsetY()-100;
	
	if(isIE == true) myIFrame.scrollBy(scrollAmountX, scrollAmountY);
	else myIFrame.contentWindow.scrollBy(scrollAmountX, scrollAmountY);
}


/**********************************************/
/****** DOCUMENT SYNCHRONIZATION *****/

// paramAction: i (insert), u (update), d (delete)
// paramText: the new text for the affected line
// paramLineNum: the line where the action will take place
function updateDocument( paramAction, paramText, paramLineNum ) {
	//this needs a lot of work still... cory is working on it.
	//don't do anything here for now
	return;
	new Ajax.Request('./handlers/documentUpdate.php?docID='+XPODoc.documentID+'&action='+paramAction+'&text='+paramText+'&lNum='+paramLineNum, {
		method:'get',
		// get a response indicating if the change is acceptable
		onSuccess: function(transport) {			
			//alert(transport.responseText);
		}		
	});
}

function updateLineLock( line ) {
	new Ajax.Request('./documents/lineLock/updateLineLock.php?curLine='+line+'&docID='+XPODoc.documentID, {
		method:'get'		
	});
}



/*************************************************/
/******* INITIALIZATION / LOAD FUNCTIONS *****/

function init() {
	/* Get handle on main document object */
	mainDoc = document;	
	
	/* BROWSER DETECTION */
	var ua = navigator.userAgent.toLowerCase();	
	isFF = (ua.indexOf("firefox") != -1);
	isIE = (ua.indexOf("msie") != -1);
	isChrome = (ua.indexOf("chrome") != -1);
	isSafari = (ua.indexOf("safari") != -1) && (ua.indexOf("chrome") == -1);
	
	/* Get browser-dependent handle on the iFrame and the iFrame's content document */
	if(isIE == false) myIFrame = document.getElementById("myI");
	else myIFrame = frames["myI"];
		
	/* Initialize our text document data structure */
	XPODoc = new TextDocument();
}

/* This function is responsible for (re-)initializing the text data structure, given a document ID, text, and setting the access mode */
function loadNewDoc(docID, docText, accessMode) {
	/* Ensure that the text data structure is clean  */
	// NOTE:  Couldn't we instead, simply do:  XPODoc = new TextDocument();  ????  Would that be less efficient?
	XPODoc.blankDocument();
	XPODoc.documentID = docID;
	
	/* Populate the XPODoc data structure */
	XPODoc.insertText(docText);
	
	/* Get handle on iFrame's content document */
	if(isIE == true) guiDoc = myIFrame.document;
	else guiDoc = myIFrame.contentWindow.document;
	
	/* Set the access mode.  If not readonly, it shall be assume read-write */
	readOnly = (accessMode == "r");
	
	/* Add event listeners, but only if the mode is read-write (NOT readOnly) */
	if(readOnly == false){
		if(isIE == true || isChrome == true || isSafari == true){
			guiDoc.onclick = onClickFunction;
			guiDoc.onkeypress = onKeyPressFunction;
			guiDoc.onkeydown = onKeyDownFunction;
		}
		else{
			guiDoc.addEventListener("click", onClickFunction, true);
			guiDoc.addEventListener("keydown", onKeyDownFunction, true);
			guiDoc.addEventListener("keypress", onKeyPressFunction, true);
		}
	}
	else{ // Remove event listeners because we are in readOnly mode
		if(isIE == true || isChrome == true || isSafari == true){
			guiDoc.onclick = null;
			guiDoc.onkeydown = null;
			guiDoc.onkeypress = null;
		}
		else{
			guiDoc.removeEventListener("click", onClickFunction, true);
			guiDoc.removeEventListener("keydown", onKeyDownFunction, true);
			guiDoc.removeEventListener("keypress", onKeyPressFunction, true);
		}
	}
	
	/* Ensure that the text 'window' has the focus, thus allowing immediate editing (if eventListeners are active, of course) */
	if(isIE == true) myIFrame.focus();
	else myIFrame.contentWindow.focus();
	
	/* Initialize the cursor to the starting position */
	setCursor(0,0);
	
	/* Render the entire document */
	refreshDocument();
	renderCursor();
}



/***************************************************/
/*********** EVENT HANDLER FUNCTIONS ***********/

/* This function is the handler for the onclick event. */
onClickFunction = function( paramEvent ){
	var oldCursorLine = cursorLine;
	clearFormatting(cursorLine);
	captureMousePos(paramEvent);
	deriveCursorForDocument(mouseX,mouseY,XPODoc);
	renderCursor();
	if(oldCursorLine != cursorLine) updateLineLock(cursorLine);
}

/* This function is the handler of the keydown event.  Mainly, this function will execute the typeSpecial function */
onKeyDownFunction = function( paramEvent ) {
	var oldCursorLine = cursorLine;
	clearFormatting(cursorLine);
	
	// Determine the keyCode of the pressed key (browser-dependent implementation)
	var key;
	if(isIE == true) key = myIFrame.window.event.keyCode;
	else key = paramEvent.keyCode;

	// if typeSpecial actually did something, it returns false...
	var returnValue = typeSpecial( key );
	
	renderCursor();
	adjustScroll();
	if(oldCursorLine != cursorLine) updateLineLock(cursorLine);
	
	return returnValue;	//  ... and if typeSpecial returns false, we don't want the event to bubble, so pass this return value along
}


/* This function is the handler for the keypress event.  Mainly, this function will execute the typeCharacter function, if applicable */
onKeyPressFunction = function( paramEvent ){
	var oldCursorLine = cursorLine;
	clearFormatting(cursorLine);
	
	// Determine the ASCII code of the to-be-typed character (browser-dependent implementation)
	var key;
	if(isFF == true) key = paramEvent.charCode;
	else if(isIE == true) key = myIFrame.window.event.keyCode;
	else if(isChrome == true || isSafari == true) key = paramEvent.keyCode;
	else alert('an unknown browser... editing may not work.');

	// If a valid character (nonzero), then type it
	if ( key != 0 ) typeCharacter( key );
	
	renderCursor();
	adjustScroll();
	if(oldCursorLine != cursorLine) updateLineLock(cursorLine);
}

/* This function is the handler of the mousedown event */
onMouseDownFunction = function( paramEvent ) {

}
</script>
<iframe id="myI" name="myI" src="./editor/editableContent.html" style="width:100%;height:100%;"></iframe>